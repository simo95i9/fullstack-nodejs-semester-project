{
  "version": 3,
  "sources": ["../node_modules/jsbi/tsc-out/jsbi.mjs", "../node_modules/@js-temporal/polyfill/tsc-out/intrinsicclass.js", "../node_modules/@js-temporal/polyfill/tsc-out/slots.js", "../node_modules/@js-temporal/polyfill/tsc-out/calendar.js", "../node_modules/@js-temporal/polyfill/tsc-out/ecmascript.js", "../node_modules/@js-temporal/polyfill/tsc-out/regex.js", "../node_modules/@js-temporal/polyfill/tsc-out/intl.js", "../node_modules/@js-temporal/polyfill/tsc-out/instant.js", "../node_modules/@js-temporal/polyfill/tsc-out/plaindate.js", "../node_modules/@js-temporal/polyfill/tsc-out/plaindatetime.js", "../node_modules/@js-temporal/polyfill/tsc-out/duration.js", "../node_modules/@js-temporal/polyfill/tsc-out/plainmonthday.js", "../node_modules/@js-temporal/polyfill/tsc-out/now.js", "../node_modules/@js-temporal/polyfill/tsc-out/plaintime.js", "../node_modules/@js-temporal/polyfill/tsc-out/timezone.js", "../node_modules/@js-temporal/polyfill/tsc-out/plainyearmonth.js", "../node_modules/@js-temporal/polyfill/tsc-out/zoneddatetime.js", "../node_modules/@js-temporal/polyfill/tsc-out/legacydate.js", "../node_modules/@js-temporal/polyfill/tsc-out/index.js", "../src/main.js"],
  "sourcesContent": ["// Copyright 2018 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \u201CLicense\u201D);\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// <https://apache.org/licenses/LICENSE-2.0>.\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \u201CAS IS\u201D BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass JSBI extends Array {\n    constructor(length, sign) {\n        super(length);\n        this.sign = sign;\n        // Explicitly set the prototype as per\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, JSBI.prototype);\n        if (length > JSBI.__kMaxLength) {\n            throw new RangeError('Maximum BigInt size exceeded');\n        }\n    }\n    static BigInt(arg) {\n        if (typeof arg === 'number') {\n            if (arg === 0)\n                return JSBI.__zero();\n            if (JSBI.__isOneDigitInt(arg)) {\n                if (arg < 0) {\n                    return JSBI.__oneDigit(-arg, true);\n                }\n                return JSBI.__oneDigit(arg, false);\n            }\n            if (!Number.isFinite(arg) || Math.floor(arg) !== arg) {\n                throw new RangeError('The number ' + arg + ' cannot be converted to ' +\n                    'BigInt because it is not an integer');\n            }\n            return JSBI.__fromDouble(arg);\n        }\n        else if (typeof arg === 'string') {\n            const result = JSBI.__fromString(arg);\n            if (result === null) {\n                throw new SyntaxError('Cannot convert ' + arg + ' to a BigInt');\n            }\n            return result;\n        }\n        else if (typeof arg === 'boolean') {\n            if (arg === true) {\n                return JSBI.__oneDigit(1, false);\n            }\n            return JSBI.__zero();\n        }\n        else if (typeof arg === 'object') {\n            if (arg.constructor === JSBI)\n                return arg;\n            const primitive = JSBI.__toPrimitive(arg);\n            return JSBI.BigInt(primitive);\n        }\n        throw new TypeError('Cannot convert ' + arg + ' to a BigInt');\n    }\n    toDebugString() {\n        const result = ['BigInt['];\n        for (const digit of this) {\n            result.push((digit ? (digit >>> 0).toString(16) : digit) + ', ');\n        }\n        result.push(']');\n        return result.join('');\n    }\n    toString(radix = 10) {\n        if (radix < 2 || radix > 36) {\n            throw new RangeError('toString() radix argument must be between 2 and 36');\n        }\n        if (this.length === 0)\n            return '0';\n        if ((radix & (radix - 1)) === 0) {\n            return JSBI.__toStringBasePowerOfTwo(this, radix);\n        }\n        return JSBI.__toStringGeneric(this, radix, false);\n    }\n    valueOf() {\n        throw new Error('Convert JSBI instances to native numbers using `toNumber`.');\n    }\n    // Equivalent of \"Number(my_bigint)\" in the native implementation.\n    // TODO: add more tests\n    static toNumber(x) {\n        const xLength = x.length;\n        if (xLength === 0)\n            return 0;\n        if (xLength === 1) {\n            const value = x.__unsignedDigit(0);\n            return x.sign ? -value : value;\n        }\n        const xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        if (xBitLength > 1024)\n            return x.sign ? -Infinity : Infinity;\n        let exponent = xBitLength - 1;\n        let currentDigit = xMsd;\n        let digitIndex = xLength - 1;\n        const shift = msdLeadingZeros + 3;\n        let mantissaHigh = (shift === 32) ? 0 : currentDigit << shift;\n        mantissaHigh >>>= 12;\n        const mantissaHighBitsUnset = shift - 12;\n        let mantissaLow = (shift >= 12) ? 0 : (currentDigit << (20 + shift));\n        let mantissaLowBitsUnset = 20 + shift;\n        if (mantissaHighBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            mantissaHigh |= (currentDigit >>> (30 - mantissaHighBitsUnset));\n            mantissaLow = currentDigit << mantissaHighBitsUnset + 2;\n            mantissaLowBitsUnset = mantissaHighBitsUnset + 2;\n        }\n        while (mantissaLowBitsUnset > 0 && digitIndex > 0) {\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            if (mantissaLowBitsUnset >= 30) {\n                mantissaLow |= (currentDigit << (mantissaLowBitsUnset - 30));\n            }\n            else {\n                mantissaLow |= (currentDigit >>> (30 - mantissaLowBitsUnset));\n            }\n            mantissaLowBitsUnset -= 30;\n        }\n        const rounding = JSBI.__decideRounding(x, mantissaLowBitsUnset, digitIndex, currentDigit);\n        if (rounding === 1 || (rounding === 0 && (mantissaLow & 1) === 1)) {\n            mantissaLow = (mantissaLow + 1) >>> 0;\n            if (mantissaLow === 0) {\n                // Incrementing mantissaLow overflowed.\n                mantissaHigh++;\n                if ((mantissaHigh >>> 20) !== 0) {\n                    // Incrementing mantissaHigh overflowed.\n                    mantissaHigh = 0;\n                    exponent++;\n                    if (exponent > 1023) {\n                        // Incrementing the exponent overflowed.\n                        return x.sign ? -Infinity : Infinity;\n                    }\n                }\n            }\n        }\n        const signBit = x.sign ? (1 << 31) : 0;\n        exponent = (exponent + 0x3FF) << 20;\n        JSBI.__kBitConversionInts[1] = signBit | exponent | mantissaHigh;\n        JSBI.__kBitConversionInts[0] = mantissaLow;\n        return JSBI.__kBitConversionDouble[0];\n    }\n    // Operations.\n    static unaryMinus(x) {\n        if (x.length === 0)\n            return x;\n        const result = x.__copy();\n        result.sign = !x.sign;\n        return result;\n    }\n    static bitwiseNot(x) {\n        if (x.sign) {\n            // ~(-x) == ~(~(x-1)) == x-1\n            return JSBI.__absoluteSubOne(x).__trim();\n        }\n        // ~x == -x-1 == -(x+1)\n        return JSBI.__absoluteAddOne(x, true);\n    }\n    static exponentiate(x, y) {\n        if (y.sign) {\n            throw new RangeError('Exponent must be positive');\n        }\n        if (y.length === 0) {\n            return JSBI.__oneDigit(1, false);\n        }\n        if (x.length === 0)\n            return x;\n        if (x.length === 1 && x.__digit(0) === 1) {\n            // (-1) ** even_number == 1.\n            if (x.sign && (y.__digit(0) & 1) === 0) {\n                return JSBI.unaryMinus(x);\n            }\n            // (-1) ** odd_number == -1, 1 ** anything == 1.\n            return x;\n        }\n        // For all bases >= 2, very large exponents would lead to unrepresentable\n        // results.\n        if (y.length > 1)\n            throw new RangeError('BigInt too big');\n        let expValue = y.__unsignedDigit(0);\n        if (expValue === 1)\n            return x;\n        if (expValue >= JSBI.__kMaxLengthBits) {\n            throw new RangeError('BigInt too big');\n        }\n        if (x.length === 1 && x.__digit(0) === 2) {\n            // Fast path for 2^n.\n            const neededDigits = 1 + ((expValue / 30) | 0);\n            const sign = x.sign && ((expValue & 1) !== 0);\n            const result = new JSBI(neededDigits, sign);\n            result.__initializeDigits();\n            // All bits are zero. Now set the n-th bit.\n            const msd = 1 << (expValue % 30);\n            result.__setDigit(neededDigits - 1, msd);\n            return result;\n        }\n        let result = null;\n        let runningSquare = x;\n        // This implicitly sets the result's sign correctly.\n        if ((expValue & 1) !== 0)\n            result = x;\n        expValue >>= 1;\n        for (; expValue !== 0; expValue >>= 1) {\n            runningSquare = JSBI.multiply(runningSquare, runningSquare);\n            if ((expValue & 1) !== 0) {\n                if (result === null) {\n                    result = runningSquare;\n                }\n                else {\n                    result = JSBI.multiply(result, runningSquare);\n                }\n            }\n        }\n        // TODO see if there's a way for tsc to infer this will always happen?\n        return result;\n    }\n    static multiply(x, y) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return y;\n        let resultLength = x.length + y.length;\n        if (x.__clzmsd() + y.__clzmsd() >= 30) {\n            resultLength--;\n        }\n        const result = new JSBI(resultLength, x.sign !== y.sign);\n        result.__initializeDigits();\n        for (let i = 0; i < x.length; i++) {\n            JSBI.__multiplyAccumulate(y, x.__digit(i), result, i);\n        }\n        return result.__trim();\n    }\n    static divide(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return JSBI.__zero();\n        const resultSign = x.sign !== y.sign;\n        const divisor = y.__unsignedDigit(0);\n        let quotient;\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1) {\n                return resultSign === x.sign ? x : JSBI.unaryMinus(x);\n            }\n            quotient = JSBI.__absoluteDivSmall(x, divisor, null);\n        }\n        else {\n            quotient = JSBI.__absoluteDivLarge(x, y, true, false);\n        }\n        quotient.sign = resultSign;\n        return quotient.__trim();\n    }\n    static remainder(x, y) {\n        if (y.length === 0)\n            throw new RangeError('Division by zero');\n        if (JSBI.__absoluteCompare(x, y) < 0)\n            return x;\n        const divisor = y.__unsignedDigit(0);\n        if (y.length === 1 && divisor <= 0x7FFF) {\n            if (divisor === 1)\n                return JSBI.__zero();\n            const remainderDigit = JSBI.__absoluteModSmall(x, divisor);\n            if (remainderDigit === 0)\n                return JSBI.__zero();\n            return JSBI.__oneDigit(remainderDigit, x.sign);\n        }\n        const remainder = JSBI.__absoluteDivLarge(x, y, false, true);\n        remainder.sign = x.sign;\n        return remainder.__trim();\n    }\n    static add(x, y) {\n        const sign = x.sign;\n        if (sign === y.sign) {\n            // x + y == x + y\n            // -x + -y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x + -y == x - y == -(y - x)\n        // -x + y == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static subtract(x, y) {\n        const sign = x.sign;\n        if (sign !== y.sign) {\n            // x - (-y) == x + y\n            // (-x) - y == -(x + y)\n            return JSBI.__absoluteAdd(x, y, sign);\n        }\n        // x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        if (JSBI.__absoluteCompare(x, y) >= 0) {\n            return JSBI.__absoluteSub(x, y, sign);\n        }\n        return JSBI.__absoluteSub(y, x, !sign);\n    }\n    static leftShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__rightShiftByAbsolute(x, y);\n        return JSBI.__leftShiftByAbsolute(x, y);\n    }\n    static signedRightShift(x, y) {\n        if (y.length === 0 || x.length === 0)\n            return x;\n        if (y.sign)\n            return JSBI.__leftShiftByAbsolute(x, y);\n        return JSBI.__rightShiftByAbsolute(x, y);\n    }\n    static unsignedRightShift() {\n        throw new TypeError('BigInts have no unsigned right shift; use >> instead');\n    }\n    static lessThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) < 0;\n    }\n    static lessThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) <= 0;\n    }\n    static greaterThan(x, y) {\n        return JSBI.__compareToBigInt(x, y) > 0;\n    }\n    static greaterThanOrEqual(x, y) {\n        return JSBI.__compareToBigInt(x, y) >= 0;\n    }\n    static equal(x, y) {\n        if (x.sign !== y.sign)\n            return false;\n        if (x.length !== y.length)\n            return false;\n        for (let i = 0; i < x.length; i++) {\n            if (x.__digit(i) !== y.__digit(i))\n                return false;\n        }\n        return true;\n    }\n    static notEqual(x, y) {\n        return !JSBI.equal(x, y);\n    }\n    static bitwiseAnd(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteAnd(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            const resultLength = Math.max(x.length, y.length) + 1;\n            // (-x) & (-y) == ~(x-1) & ~(y-1) == ~((x-1) | (y-1))\n            // == -(((x-1) | (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteOr(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x & (-y) == x & ~(y-1) == x &~ (y-1)\n        return JSBI.__absoluteAndNot(x, JSBI.__absoluteSubOne(y)).__trim();\n    }\n    static bitwiseXor(x, y) {\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteXor(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) ^ (-y) == ~(x-1) ^ ~(y-1) == (x-1) ^ (y-1)\n            const resultLength = Math.max(x.length, y.length);\n            const result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            return JSBI.__absoluteXor(result, y1, result).__trim();\n        }\n        const resultLength = Math.max(x.length, y.length) + 1;\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x ^ (-y) == x ^ ~(y-1) == ~(x ^ (y-1)) == -((x ^ (y-1)) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteXor(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static bitwiseOr(x, y) {\n        const resultLength = Math.max(x.length, y.length);\n        if (!x.sign && !y.sign) {\n            return JSBI.__absoluteOr(x, y).__trim();\n        }\n        else if (x.sign && y.sign) {\n            // (-x) | (-y) == ~(x-1) | ~(y-1) == ~((x-1) & (y-1))\n            // == -(((x-1) & (y-1)) + 1)\n            let result = JSBI.__absoluteSubOne(x, resultLength);\n            const y1 = JSBI.__absoluteSubOne(y);\n            result = JSBI.__absoluteAnd(result, y1, result);\n            return JSBI.__absoluteAddOne(result, true, result).__trim();\n        }\n        // Assume that x is the positive BigInt.\n        if (x.sign) {\n            [x, y] = [y, x];\n        }\n        // x | (-y) == x | ~(y-1) == ~((y-1) &~ x) == -(((y-1) ~& x) + 1)\n        let result = JSBI.__absoluteSubOne(y, resultLength);\n        result = JSBI.__absoluteAndNot(result, x, result);\n        return JSBI.__absoluteAddOne(result, true, result).__trim();\n    }\n    static asIntN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} has less than {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const topDigit = x.__unsignedDigit(neededLength - 1);\n        const compareDigit = 1 << ((n - 1) % 30);\n        if (x.length === neededLength && topDigit < compareDigit)\n            return x;\n        // Otherwise truncate and simulate two's complement.\n        const hasBit = (topDigit & compareDigit) === compareDigit;\n        if (!hasBit)\n            return JSBI.__truncateToNBits(n, x);\n        if (!x.sign)\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, true);\n        if ((topDigit & (compareDigit - 1)) === 0) {\n            for (let i = neededLength - 2; i >= 0; i--) {\n                if (x.__digit(i) !== 0) {\n                    return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n                }\n            }\n            if (x.length === neededLength && topDigit === compareDigit)\n                return x;\n            return JSBI.__truncateToNBits(n, x);\n        }\n        return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n    }\n    static asUintN(n, x) {\n        if (x.length === 0)\n            return x;\n        n = Math.floor(n);\n        if (n < 0) {\n            throw new RangeError('Invalid value: not (convertible to) a safe integer');\n        }\n        if (n === 0)\n            return JSBI.__zero();\n        // If {x} is negative, simulate two's complement representation.\n        if (x.sign) {\n            if (n > JSBI.__kMaxLengthBits) {\n                throw new RangeError('BigInt too big');\n            }\n            return JSBI.__truncateAndSubFromPowerOfTwo(n, x, false);\n        }\n        // If {x} is positive and has up to {n} bits, return it directly.\n        if (n >= JSBI.__kMaxLengthBits)\n            return x;\n        const neededLength = ((n + 29) / 30) | 0;\n        if (x.length < neededLength)\n            return x;\n        const bitsInTopDigit = n % 30;\n        if (x.length == neededLength) {\n            if (bitsInTopDigit === 0)\n                return x;\n            const topDigit = x.__digit(neededLength - 1);\n            if ((topDigit >>> bitsInTopDigit) === 0)\n                return x;\n        }\n        // Otherwise, truncate.\n        return JSBI.__truncateToNBits(n, x);\n    }\n    // Operators.\n    static ADD(x, y) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string') {\n            if (typeof y !== 'string')\n                y = y.toString();\n            return x + y;\n        }\n        if (typeof y === 'string') {\n            return x.toString() + y;\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x) && JSBI.__isBigInt(y)) {\n            return JSBI.add(x, y);\n        }\n        if (typeof x === 'number' && typeof y === 'number') {\n            return x + y;\n        }\n        throw new TypeError('Cannot mix BigInt and other types, use explicit conversions');\n    }\n    static LT(x, y) {\n        return JSBI.__compare(x, y, 0);\n    }\n    static LE(x, y) {\n        return JSBI.__compare(x, y, 1);\n    }\n    static GT(x, y) {\n        return JSBI.__compare(x, y, 2);\n    }\n    static GE(x, y) {\n        return JSBI.__compare(x, y, 3);\n    }\n    static EQ(x, y) {\n        while (true) {\n            if (JSBI.__isBigInt(x)) {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.equal(x, y);\n                return JSBI.EQ(y, x);\n            }\n            else if (typeof x === 'number') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'string') {\n                if (JSBI.__isBigInt(y)) {\n                    x = JSBI.__fromString(x);\n                    if (x === null)\n                        return false;\n                    return JSBI.equal(x, y);\n                }\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'boolean') {\n                if (JSBI.__isBigInt(y))\n                    return JSBI.__equalToNumber(y, +x);\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'symbol') {\n                if (JSBI.__isBigInt(y))\n                    return false;\n                if (typeof y !== 'object')\n                    return x == y;\n                y = JSBI.__toPrimitive(y);\n            }\n            else if (typeof x === 'object') {\n                if (typeof y === 'object' && y.constructor !== JSBI)\n                    return x == y;\n                x = JSBI.__toPrimitive(x);\n            }\n            else {\n                return x == y;\n            }\n        }\n    }\n    static NE(x, y) {\n        return !JSBI.EQ(x, y);\n    }\n    // DataView-related functionality.\n    static DataViewGetBigInt64(dataview, byteOffset, littleEndian = false) {\n        return JSBI.asIntN(64, JSBI.DataViewGetBigUint64(dataview, byteOffset, littleEndian));\n    }\n    static DataViewGetBigUint64(dataview, byteOffset, littleEndian = false) {\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        const high = dataview.getUint32(byteOffset + h, littleEndian);\n        const low = dataview.getUint32(byteOffset + l, littleEndian);\n        const result = new JSBI(3, false);\n        result.__setDigit(0, low & 0x3FFFFFFF);\n        result.__setDigit(1, ((high & 0xFFFFFFF) << 2) | (low >>> 30));\n        result.__setDigit(2, high >>> 28);\n        return result.__trim();\n    }\n    static DataViewSetBigInt64(dataview, byteOffset, value, littleEndian = false) {\n        JSBI.DataViewSetBigUint64(dataview, byteOffset, value, littleEndian);\n    }\n    static DataViewSetBigUint64(dataview, byteOffset, value, littleEndian = false) {\n        value = JSBI.asUintN(64, value);\n        let high = 0;\n        let low = 0;\n        if (value.length > 0) {\n            low = value.__digit(0);\n            if (value.length > 1) {\n                const d1 = value.__digit(1);\n                low = low | d1 << 30;\n                high = d1 >>> 2;\n                if (value.length > 2) {\n                    high = high | (value.__digit(2) << 28);\n                }\n            }\n        }\n        const [h, l] = littleEndian ? [4, 0] : [0, 4];\n        dataview.setUint32(byteOffset + h, high, littleEndian);\n        dataview.setUint32(byteOffset + l, low, littleEndian);\n    }\n    // Helpers.\n    static __zero() {\n        return new JSBI(0, false);\n    }\n    static __oneDigit(value, sign) {\n        const result = new JSBI(1, sign);\n        result.__setDigit(0, value);\n        return result;\n    }\n    __copy() {\n        const result = new JSBI(this.length, this.sign);\n        for (let i = 0; i < this.length; i++) {\n            result[i] = this[i];\n        }\n        return result;\n    }\n    __trim() {\n        let newLength = this.length;\n        let last = this[newLength - 1];\n        while (last === 0) {\n            newLength--;\n            last = this[newLength - 1];\n            this.pop();\n        }\n        if (newLength === 0)\n            this.sign = false;\n        return this;\n    }\n    __initializeDigits() {\n        for (let i = 0; i < this.length; i++) {\n            this[i] = 0;\n        }\n    }\n    static __decideRounding(x, mantissaBitsUnset, digitIndex, currentDigit) {\n        if (mantissaBitsUnset > 0)\n            return -1;\n        let topUnconsumedBit;\n        if (mantissaBitsUnset < 0) {\n            topUnconsumedBit = -mantissaBitsUnset - 1;\n        }\n        else {\n            // {currentDigit} fit the mantissa exactly; look at the next digit.\n            if (digitIndex === 0)\n                return -1;\n            digitIndex--;\n            currentDigit = x.__digit(digitIndex);\n            topUnconsumedBit = 29;\n        }\n        // If the most significant remaining bit is 0, round down.\n        let mask = 1 << topUnconsumedBit;\n        if ((currentDigit & mask) === 0)\n            return -1;\n        // If any other remaining bit is set, round up.\n        mask -= 1;\n        if ((currentDigit & mask) !== 0)\n            return 1;\n        while (digitIndex > 0) {\n            digitIndex--;\n            if (x.__digit(digitIndex) !== 0)\n                return 1;\n        }\n        return 0;\n    }\n    static __fromDouble(value) {\n        const sign = value < 0;\n        JSBI.__kBitConversionDouble[0] = value;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        const exponent = rawExponent - 0x3FF;\n        const digits = ((exponent / 30) | 0) + 1;\n        const result = new JSBI(digits, sign);\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        // 0-indexed position of most significant bit in most significant digit.\n        const msdTopBit = exponent % 30;\n        // Number of unused bits in the mantissa. We'll keep them shifted to the\n        // left (i.e. most significant part).\n        let remainingMantissaBits = 0;\n        // Next digit under construction.\n        let digit;\n        // First, build the MSD by shifting the mantissa appropriately.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            digit = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            digit = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            digit = (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        result.__setDigit(digits - 1, digit);\n        // Then fill in the rest of the digits.\n        for (let digitIndex = digits - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                digit = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                digit = 0;\n            }\n            result.__setDigit(digitIndex, digit);\n        }\n        return result.__trim();\n    }\n    static __isWhitespace(c) {\n        if (c <= 0x0D && c >= 0x09)\n            return true;\n        if (c <= 0x9F)\n            return c === 0x20;\n        if (c <= 0x01FFFF) {\n            return c === 0xA0 || c === 0x1680;\n        }\n        if (c <= 0x02FFFF) {\n            c &= 0x01FFFF;\n            return c <= 0x0A || c === 0x28 || c === 0x29 || c === 0x2F ||\n                c === 0x5F || c === 0x1000;\n        }\n        return c === 0xFEFF;\n    }\n    static __fromString(string, radix = 0) {\n        let sign = 0;\n        let leadingZero = false;\n        const length = string.length;\n        let cursor = 0;\n        if (cursor === length)\n            return JSBI.__zero();\n        let current = string.charCodeAt(cursor);\n        // Skip whitespace.\n        while (JSBI.__isWhitespace(current)) {\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Detect radix.\n        if (current === 0x2B) { // '+'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = 1;\n        }\n        else if (current === 0x2D) { // '-'\n            if (++cursor === length)\n                return null;\n            current = string.charCodeAt(cursor);\n            sign = -1;\n        }\n        if (radix === 0) {\n            radix = 10;\n            if (current === 0x30) { // '0'\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    radix = 16;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x4F || current === 0x6F) { // 'O' or 'o'\n                    radix = 8;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else if (current === 0x42 || current === 0x62) { // 'B' or 'b'\n                    radix = 2;\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        else if (radix === 16) {\n            if (current === 0x30) { // '0'\n                // Allow \"0x\" prefix.\n                if (++cursor === length)\n                    return JSBI.__zero();\n                current = string.charCodeAt(cursor);\n                if (current === 0x58 || current === 0x78) { // 'X' or 'x'\n                    if (++cursor === length)\n                        return null;\n                    current = string.charCodeAt(cursor);\n                }\n                else {\n                    leadingZero = true;\n                }\n            }\n        }\n        if (sign !== 0 && radix !== 10)\n            return null;\n        // Skip leading zeros.\n        while (current === 0x30) {\n            leadingZero = true;\n            if (++cursor === length)\n                return JSBI.__zero();\n            current = string.charCodeAt(cursor);\n        }\n        // Allocate result.\n        const chars = length - cursor;\n        let bitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        let roundup = JSBI.__kBitsPerCharTableMultiplier - 1;\n        if (chars > (1 << 30) / bitsPerChar)\n            return null;\n        const bitsMin = (bitsPerChar * chars + roundup) >>> JSBI.__kBitsPerCharTableShift;\n        const resultLength = ((bitsMin + 29) / 30) | 0;\n        const result = new JSBI(resultLength, false);\n        // Parse.\n        const limDigit = radix < 10 ? radix : 10;\n        const limAlpha = radix > 10 ? radix - 10 : 0;\n        if ((radix & (radix - 1)) === 0) {\n            // Power-of-two radix.\n            bitsPerChar >>= JSBI.__kBitsPerCharTableShift;\n            const parts = [];\n            const partsBits = [];\n            let done = false;\n            do {\n                let part = 0;\n                let bits = 0;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    bits += bitsPerChar;\n                    part = (part << bitsPerChar) | d;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                    if (bits + bitsPerChar > 30)\n                        break;\n                }\n                parts.push(part);\n                partsBits.push(bits);\n            } while (!done);\n            JSBI.__fillFromParts(result, parts, partsBits);\n        }\n        else {\n            result.__initializeDigits();\n            let done = false;\n            let charsSoFar = 0;\n            do {\n                let part = 0;\n                let multiplier = 1;\n                while (true) {\n                    let d;\n                    if (((current - 48) >>> 0) < limDigit) {\n                        d = current - 48;\n                    }\n                    else if ((((current | 32) - 97) >>> 0) < limAlpha) {\n                        d = (current | 32) - 87;\n                    }\n                    else {\n                        done = true;\n                        break;\n                    }\n                    const m = multiplier * radix;\n                    if (m > 0x3FFFFFFF)\n                        break;\n                    multiplier = m;\n                    part = part * radix + d;\n                    charsSoFar++;\n                    if (++cursor === length) {\n                        done = true;\n                        break;\n                    }\n                    current = string.charCodeAt(cursor);\n                }\n                roundup = JSBI.__kBitsPerCharTableMultiplier * 30 - 1;\n                const digitsSoFar = (((bitsPerChar * charsSoFar + roundup) >>>\n                    JSBI.__kBitsPerCharTableShift) / 30) | 0;\n                result.__inplaceMultiplyAdd(multiplier, part, digitsSoFar);\n            } while (!done);\n        }\n        if (cursor !== length) {\n            if (!JSBI.__isWhitespace(current))\n                return null;\n            for (cursor++; cursor < length; cursor++) {\n                current = string.charCodeAt(cursor);\n                if (!JSBI.__isWhitespace(current))\n                    return null;\n            }\n        }\n        // Get result.\n        result.sign = (sign === -1);\n        return result.__trim();\n    }\n    static __fillFromParts(result, parts, partsBits) {\n        let digitIndex = 0;\n        let digit = 0;\n        let bitsInDigit = 0;\n        for (let i = parts.length - 1; i >= 0; i--) {\n            const part = parts[i];\n            const partBits = partsBits[i];\n            digit |= (part << bitsInDigit);\n            bitsInDigit += partBits;\n            if (bitsInDigit === 30) {\n                result.__setDigit(digitIndex++, digit);\n                bitsInDigit = 0;\n                digit = 0;\n            }\n            else if (bitsInDigit > 30) {\n                result.__setDigit(digitIndex++, digit & 0x3FFFFFFF);\n                bitsInDigit -= 30;\n                digit = part >>> (partBits - bitsInDigit);\n            }\n        }\n        if (digit !== 0) {\n            if (digitIndex >= result.length)\n                throw new Error('implementation bug');\n            result.__setDigit(digitIndex++, digit);\n        }\n        for (; digitIndex < result.length; digitIndex++) {\n            result.__setDigit(digitIndex, 0);\n        }\n    }\n    static __toStringBasePowerOfTwo(x, radix) {\n        const length = x.length;\n        let bits = radix - 1;\n        bits = ((bits >>> 1) & 0x55) + (bits & 0x55);\n        bits = ((bits >>> 2) & 0x33) + (bits & 0x33);\n        bits = ((bits >>> 4) & 0x0F) + (bits & 0x0F);\n        const bitsPerChar = bits;\n        const charMask = radix - 1;\n        const msd = x.__digit(length - 1);\n        const msdLeadingZeros = JSBI.__clz30(msd);\n        const bitLength = length * 30 - msdLeadingZeros;\n        let charsRequired = ((bitLength + bitsPerChar - 1) / bitsPerChar) | 0;\n        if (x.sign)\n            charsRequired++;\n        if (charsRequired > (1 << 28))\n            throw new Error('string too long');\n        const result = new Array(charsRequired);\n        let pos = charsRequired - 1;\n        let digit = 0;\n        let availableBits = 0;\n        for (let i = 0; i < length - 1; i++) {\n            const newDigit = x.__digit(i);\n            const current = (digit | (newDigit << availableBits)) & charMask;\n            result[pos--] = JSBI.__kConversionChars[current];\n            const consumedBits = bitsPerChar - availableBits;\n            digit = newDigit >>> consumedBits;\n            availableBits = 30 - consumedBits;\n            while (availableBits >= bitsPerChar) {\n                result[pos--] = JSBI.__kConversionChars[digit & charMask];\n                digit >>>= bitsPerChar;\n                availableBits -= bitsPerChar;\n            }\n        }\n        const current = (digit | (msd << availableBits)) & charMask;\n        result[pos--] = JSBI.__kConversionChars[current];\n        digit = msd >>> (bitsPerChar - availableBits);\n        while (digit !== 0) {\n            result[pos--] = JSBI.__kConversionChars[digit & charMask];\n            digit >>>= bitsPerChar;\n        }\n        if (x.sign)\n            result[pos--] = '-';\n        if (pos !== -1)\n            throw new Error('implementation bug');\n        return result.join('');\n    }\n    static __toStringGeneric(x, radix, isRecursiveCall) {\n        const length = x.length;\n        if (length === 0)\n            return '';\n        if (length === 1) {\n            let result = x.__unsignedDigit(0).toString(radix);\n            if (isRecursiveCall === false && x.sign) {\n                result = '-' + result;\n            }\n            return result;\n        }\n        const bitLength = length * 30 - JSBI.__clz30(x.__digit(length - 1));\n        const maxBitsPerChar = JSBI.__kMaxBitsPerChar[radix];\n        const minBitsPerChar = maxBitsPerChar - 1;\n        let charsRequired = bitLength * JSBI.__kBitsPerCharTableMultiplier;\n        charsRequired += minBitsPerChar - 1;\n        charsRequired = (charsRequired / minBitsPerChar) | 0;\n        const secondHalfChars = (charsRequired + 1) >> 1;\n        // Divide-and-conquer: split by a power of {radix} that's approximately\n        // the square root of {x}, then recurse.\n        const conqueror = JSBI.exponentiate(JSBI.__oneDigit(radix, false), JSBI.__oneDigit(secondHalfChars, false));\n        let quotient;\n        let secondHalf;\n        const divisor = conqueror.__unsignedDigit(0);\n        if (conqueror.length === 1 && divisor <= 0x7FFF) {\n            quotient = new JSBI(x.length, false);\n            quotient.__initializeDigits();\n            let remainder = 0;\n            for (let i = x.length * 2 - 1; i >= 0; i--) {\n                const input = (remainder << 15) | x.__halfDigit(i);\n                quotient.__setHalfDigit(i, (input / divisor) | 0);\n                remainder = (input % divisor) | 0;\n            }\n            secondHalf = remainder.toString(radix);\n        }\n        else {\n            const divisionResult = JSBI.__absoluteDivLarge(x, conqueror, true, true);\n            quotient = divisionResult.quotient;\n            const remainder = divisionResult.remainder.__trim();\n            secondHalf = JSBI.__toStringGeneric(remainder, radix, true);\n        }\n        quotient.__trim();\n        let firstHalf = JSBI.__toStringGeneric(quotient, radix, true);\n        while (secondHalf.length < secondHalfChars) {\n            secondHalf = '0' + secondHalf;\n        }\n        if (isRecursiveCall === false && x.sign) {\n            firstHalf = '-' + firstHalf;\n        }\n        return firstHalf + secondHalf;\n    }\n    static __unequalSign(leftNegative) {\n        return leftNegative ? -1 : 1;\n    }\n    static __absoluteGreater(bothNegative) {\n        return bothNegative ? -1 : 1;\n    }\n    static __absoluteLess(bothNegative) {\n        return bothNegative ? 1 : -1;\n    }\n    static __compareToBigInt(x, y) {\n        const xSign = x.sign;\n        if (xSign !== y.sign)\n            return JSBI.__unequalSign(xSign);\n        const result = JSBI.__absoluteCompare(x, y);\n        if (result > 0)\n            return JSBI.__absoluteGreater(xSign);\n        if (result < 0)\n            return JSBI.__absoluteLess(xSign);\n        return 0;\n    }\n    static __compareToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            const xSign = x.sign;\n            const ySign = (y < 0);\n            if (xSign !== ySign)\n                return JSBI.__unequalSign(xSign);\n            if (x.length === 0) {\n                if (ySign)\n                    throw new Error('implementation bug');\n                return y === 0 ? 0 : -1;\n            }\n            // Any multi-digit BigInt is bigger than an int32.\n            if (x.length > 1)\n                return JSBI.__absoluteGreater(xSign);\n            const yAbs = Math.abs(y);\n            const xDigit = x.__unsignedDigit(0);\n            if (xDigit > yAbs)\n                return JSBI.__absoluteGreater(xSign);\n            if (xDigit < yAbs)\n                return JSBI.__absoluteLess(xSign);\n            return 0;\n        }\n        return JSBI.__compareToDouble(x, y);\n    }\n    static __compareToDouble(x, y) {\n        if (y !== y)\n            return y; // NaN.\n        if (y === Infinity)\n            return -1;\n        if (y === -Infinity)\n            return 1;\n        const xSign = x.sign;\n        const ySign = (y < 0);\n        if (xSign !== ySign)\n            return JSBI.__unequalSign(xSign);\n        if (y === 0) {\n            throw new Error('implementation bug: should be handled elsewhere');\n        }\n        if (x.length === 0)\n            return -1;\n        JSBI.__kBitConversionDouble[0] = y;\n        const rawExponent = (JSBI.__kBitConversionInts[1] >>> 20) & 0x7FF;\n        if (rawExponent === 0x7FF) {\n            throw new Error('implementation bug: handled elsewhere');\n        }\n        const exponent = rawExponent - 0x3FF;\n        if (exponent < 0) {\n            // The absolute value of y is less than 1. Only 0n has an absolute\n            // value smaller than that, but we've already covered that case.\n            return JSBI.__absoluteGreater(xSign);\n        }\n        const xLength = x.length;\n        let xMsd = x.__digit(xLength - 1);\n        const msdLeadingZeros = JSBI.__clz30(xMsd);\n        const xBitLength = xLength * 30 - msdLeadingZeros;\n        const yBitLength = exponent + 1;\n        if (xBitLength < yBitLength)\n            return JSBI.__absoluteLess(xSign);\n        if (xBitLength > yBitLength)\n            return JSBI.__absoluteGreater(xSign);\n        // Same sign, same bit length. Shift mantissa to align with x and compare\n        // bit for bit.\n        const kHiddenBit = 0x00100000;\n        let mantissaHigh = (JSBI.__kBitConversionInts[1] & 0xFFFFF) | kHiddenBit;\n        let mantissaLow = JSBI.__kBitConversionInts[0];\n        const kMantissaHighTopBit = 20;\n        const msdTopBit = 29 - msdLeadingZeros;\n        if (msdTopBit !== (((xBitLength - 1) % 30) | 0)) {\n            throw new Error('implementation bug');\n        }\n        let compareMantissa; // Shifted chunk of mantissa.\n        let remainingMantissaBits = 0;\n        // First, compare most significant digit against beginning of mantissa.\n        if (msdTopBit < kMantissaHighTopBit) {\n            const shift = kMantissaHighTopBit - msdTopBit;\n            remainingMantissaBits = shift + 32;\n            compareMantissa = mantissaHigh >>> shift;\n            mantissaHigh = (mantissaHigh << (32 - shift)) | (mantissaLow >>> shift);\n            mantissaLow = mantissaLow << (32 - shift);\n        }\n        else if (msdTopBit === kMantissaHighTopBit) {\n            remainingMantissaBits = 32;\n            compareMantissa = mantissaHigh;\n            mantissaHigh = mantissaLow;\n            mantissaLow = 0;\n        }\n        else {\n            const shift = msdTopBit - kMantissaHighTopBit;\n            remainingMantissaBits = 32 - shift;\n            compareMantissa =\n                (mantissaHigh << shift) | (mantissaLow >>> (32 - shift));\n            mantissaHigh = mantissaLow << shift;\n            mantissaLow = 0;\n        }\n        xMsd = xMsd >>> 0;\n        compareMantissa = compareMantissa >>> 0;\n        if (xMsd > compareMantissa)\n            return JSBI.__absoluteGreater(xSign);\n        if (xMsd < compareMantissa)\n            return JSBI.__absoluteLess(xSign);\n        // Then, compare additional digits against remaining mantissa bits.\n        for (let digitIndex = xLength - 2; digitIndex >= 0; digitIndex--) {\n            if (remainingMantissaBits > 0) {\n                remainingMantissaBits -= 30;\n                compareMantissa = mantissaHigh >>> 2;\n                mantissaHigh = (mantissaHigh << 30) | (mantissaLow >>> 2);\n                mantissaLow = (mantissaLow << 30);\n            }\n            else {\n                compareMantissa = 0;\n            }\n            const digit = x.__unsignedDigit(digitIndex);\n            if (digit > compareMantissa)\n                return JSBI.__absoluteGreater(xSign);\n            if (digit < compareMantissa)\n                return JSBI.__absoluteLess(xSign);\n        }\n        // Integer parts are equal; check whether {y} has a fractional part.\n        if (mantissaHigh !== 0 || mantissaLow !== 0) {\n            if (remainingMantissaBits === 0)\n                throw new Error('implementation bug');\n            return JSBI.__absoluteLess(xSign);\n        }\n        return 0;\n    }\n    static __equalToNumber(x, y) {\n        if (JSBI.__isOneDigitInt(y)) {\n            if (y === 0)\n                return x.length === 0;\n            // Any multi-digit BigInt is bigger than an int32.\n            return (x.length === 1) && (x.sign === (y < 0)) &&\n                (x.__unsignedDigit(0) === Math.abs(y));\n        }\n        return JSBI.__compareToDouble(x, y) === 0;\n    }\n    // Comparison operations, chosen such that \"op ^ 2\" reverses direction:\n    // 0 - lessThan\n    // 1 - lessThanOrEqual\n    // 2 - greaterThan\n    // 3 - greaterThanOrEqual\n    static __comparisonResultToBool(result, op) {\n        switch (op) {\n            case 0: return result < 0;\n            case 1: return result <= 0;\n            case 2: return result > 0;\n            case 3: return result >= 0;\n        }\n    }\n    static __compare(x, y, op) {\n        x = JSBI.__toPrimitive(x);\n        y = JSBI.__toPrimitive(y);\n        if (typeof x === 'string' && typeof y === 'string') {\n            switch (op) {\n                case 0: return x < y;\n                case 1: return x <= y;\n                case 2: return x > y;\n                case 3: return x >= y;\n            }\n        }\n        if (JSBI.__isBigInt(x) && typeof y === 'string') {\n            y = JSBI.__fromString(y);\n            if (y === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        if (typeof x === 'string' && JSBI.__isBigInt(y)) {\n            x = JSBI.__fromString(x);\n            if (x === null)\n                return false;\n            return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n        }\n        x = JSBI.__toNumeric(x);\n        y = JSBI.__toNumeric(y);\n        if (JSBI.__isBigInt(x)) {\n            if (JSBI.__isBigInt(y)) {\n                return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(x, y), op);\n            }\n            if (typeof y !== 'number')\n                throw new Error('implementation bug');\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(x, y), op);\n        }\n        if (typeof x !== 'number')\n            throw new Error('implementation bug');\n        if (JSBI.__isBigInt(y)) {\n            // Note that \"op ^ 2\" reverses the op's direction.\n            return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(y, x), (op ^ 2));\n        }\n        if (typeof y !== 'number')\n            throw new Error('implementation bug');\n        switch (op) {\n            case 0: return x < y;\n            case 1: return x <= y;\n            case 2: return x > y;\n            case 3: return x >= y;\n        }\n    }\n    __clzmsd() {\n        return JSBI.__clz30(this.__digit(this.length - 1));\n    }\n    static __absoluteAdd(x, y, resultSign) {\n        if (x.length < y.length)\n            return JSBI.__absoluteAdd(y, x, resultSign);\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        let resultLength = x.length;\n        if (x.__clzmsd() === 0 || (y.length === x.length && y.__clzmsd() === 0)) {\n            resultLength++;\n        }\n        const result = new JSBI(resultLength, resultSign);\n        let carry = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) + y.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (i < result.length) {\n            result.__setDigit(i, carry);\n        }\n        return result.__trim();\n    }\n    static __absoluteSub(x, y, resultSign) {\n        if (x.length === 0)\n            return x;\n        if (y.length === 0)\n            return x.sign === resultSign ? x : JSBI.unaryMinus(x);\n        const result = new JSBI(x.length, resultSign);\n        let borrow = 0;\n        let i = 0;\n        for (; i < y.length; i++) {\n            const r = x.__digit(i) - y.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < x.length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        return result.__trim();\n    }\n    static __absoluteAddOne(x, sign, result = null) {\n        const inputLength = x.length;\n        if (result === null) {\n            result = new JSBI(inputLength, sign);\n        }\n        else {\n            result.sign = sign;\n        }\n        let carry = 1;\n        for (let i = 0; i < inputLength; i++) {\n            const r = x.__digit(i) + carry;\n            carry = r >>> 30;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (carry !== 0) {\n            result.__setDigitGrow(inputLength, 1);\n        }\n        return result;\n    }\n    static __absoluteSubOne(x, resultLength) {\n        const length = x.length;\n        resultLength = resultLength || length;\n        const result = new JSBI(resultLength, false);\n        let borrow = 1;\n        for (let i = 0; i < length; i++) {\n            const r = x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (borrow !== 0)\n            throw new Error('implementation bug');\n        for (let i = length; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAnd(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = numPairs;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & y.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteAndNot(x, y, result = null) {\n        const xLength = x.length;\n        const yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) & ~y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteOr(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) | y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteXor(x, y, result = null) {\n        let xLength = x.length;\n        let yLength = y.length;\n        let numPairs = yLength;\n        if (xLength < yLength) {\n            numPairs = xLength;\n            const tmp = x;\n            const tmpLength = xLength;\n            x = y;\n            xLength = yLength;\n            y = tmp;\n            yLength = tmpLength;\n        }\n        let resultLength = xLength;\n        if (result === null) {\n            result = new JSBI(resultLength, false);\n        }\n        else {\n            resultLength = result.length;\n        }\n        let i = 0;\n        for (; i < numPairs; i++) {\n            result.__setDigit(i, x.__digit(i) ^ y.__digit(i));\n        }\n        for (; i < xLength; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        for (; i < resultLength; i++) {\n            result.__setDigit(i, 0);\n        }\n        return result;\n    }\n    static __absoluteCompare(x, y) {\n        const diff = x.length - y.length;\n        if (diff !== 0)\n            return diff;\n        let i = x.length - 1;\n        while (i >= 0 && x.__digit(i) === y.__digit(i))\n            i--;\n        if (i < 0)\n            return 0;\n        return x.__unsignedDigit(i) > y.__unsignedDigit(i) ? 1 : -1;\n    }\n    static __multiplyAccumulate(multiplicand, multiplier, accumulator, accumulatorIndex) {\n        if (multiplier === 0)\n            return;\n        const m2Low = multiplier & 0x7FFF;\n        const m2High = multiplier >>> 15;\n        let carry = 0;\n        let high = 0;\n        for (let i = 0; i < multiplicand.length; i++, accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            const m1 = multiplicand.__digit(i);\n            const m1Low = m1 & 0x7FFF;\n            const m1High = m1 >>> 15;\n            const rLow = JSBI.__imul(m1Low, m2Low);\n            const rMid1 = JSBI.__imul(m1Low, m2High);\n            const rMid2 = JSBI.__imul(m1High, m2Low);\n            const rHigh = JSBI.__imul(m1High, m2High);\n            acc += high + rLow + carry;\n            carry = acc >>> 30;\n            acc &= 0x3FFFFFFF;\n            acc += ((rMid1 & 0x7FFF) << 15) + ((rMid2 & 0x7FFF) << 15);\n            carry += acc >>> 30;\n            high = rHigh + (rMid1 >>> 15) + (rMid2 >>> 15);\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n        for (; carry !== 0 || high !== 0; accumulatorIndex++) {\n            let acc = accumulator.__digit(accumulatorIndex);\n            acc += carry + high;\n            high = 0;\n            carry = acc >>> 30;\n            accumulator.__setDigit(accumulatorIndex, acc & 0x3FFFFFFF);\n        }\n    }\n    static __internalMultiplyAdd(source, factor, summand, n, result) {\n        let carry = summand;\n        let high = 0;\n        for (let i = 0; i < n; i++) {\n            const digit = source.__digit(i);\n            const rx = JSBI.__imul(digit & 0x7FFF, factor);\n            const ry = JSBI.__imul(digit >>> 15, factor);\n            const r = rx + ((ry & 0x7FFF) << 15) + high + carry;\n            carry = r >>> 30;\n            high = ry >>> 15;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        if (result.length > n) {\n            result.__setDigit(n++, carry + high);\n            while (n < result.length) {\n                result.__setDigit(n++, 0);\n            }\n        }\n        else {\n            if (carry + high !== 0)\n                throw new Error('implementation bug');\n        }\n    }\n    __inplaceMultiplyAdd(multiplier, summand, length) {\n        if (length > this.length)\n            length = this.length;\n        const mLow = multiplier & 0x7FFF;\n        const mHigh = multiplier >>> 15;\n        let carry = 0;\n        let high = summand;\n        for (let i = 0; i < length; i++) {\n            const d = this.__digit(i);\n            const dLow = d & 0x7FFF;\n            const dHigh = d >>> 15;\n            const pLow = JSBI.__imul(dLow, mLow);\n            const pMid1 = JSBI.__imul(dLow, mHigh);\n            const pMid2 = JSBI.__imul(dHigh, mLow);\n            const pHigh = JSBI.__imul(dHigh, mHigh);\n            let result = high + pLow + carry;\n            carry = result >>> 30;\n            result &= 0x3FFFFFFF;\n            result += ((pMid1 & 0x7FFF) << 15) + ((pMid2 & 0x7FFF) << 15);\n            carry += result >>> 30;\n            high = pHigh + (pMid1 >>> 15) + (pMid2 >>> 15);\n            this.__setDigit(i, result & 0x3FFFFFFF);\n        }\n        if (carry !== 0 || high !== 0) {\n            throw new Error('implementation bug');\n        }\n    }\n    static __absoluteDivSmall(x, divisor, quotient = null) {\n        if (quotient === null)\n            quotient = new JSBI(x.length, false);\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i -= 2) {\n            let input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            const upperHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            input = ((remainder << 15) | x.__halfDigit(i - 1)) >>> 0;\n            const lowerHalf = (input / divisor) | 0;\n            remainder = (input % divisor) | 0;\n            quotient.__setDigit(i >>> 1, (upperHalf << 15) | lowerHalf);\n        }\n        return quotient;\n    }\n    static __absoluteModSmall(x, divisor) {\n        let remainder = 0;\n        for (let i = x.length * 2 - 1; i >= 0; i--) {\n            const input = ((remainder << 15) | x.__halfDigit(i)) >>> 0;\n            remainder = (input % divisor) | 0;\n        }\n        return remainder;\n    }\n    static __absoluteDivLarge(dividend, divisor, wantQuotient, wantRemainder) {\n        const n = divisor.__halfDigitLength();\n        const n2 = divisor.length;\n        const m = dividend.__halfDigitLength() - n;\n        let q = null;\n        if (wantQuotient) {\n            q = new JSBI((m + 2) >>> 1, false);\n            q.__initializeDigits();\n        }\n        const qhatv = new JSBI((n + 2) >>> 1, false);\n        qhatv.__initializeDigits();\n        // D1.\n        const shift = JSBI.__clz15(divisor.__halfDigit(n - 1));\n        if (shift > 0) {\n            divisor = JSBI.__specialLeftShift(divisor, shift, 0 /* add no digits*/);\n        }\n        const u = JSBI.__specialLeftShift(dividend, shift, 1 /* add one digit */);\n        // D2.\n        const vn1 = divisor.__halfDigit(n - 1);\n        let halfDigitBuffer = 0;\n        for (let j = m; j >= 0; j--) {\n            // D3.\n            let qhat = 0x7FFF;\n            const ujn = u.__halfDigit(j + n);\n            if (ujn !== vn1) {\n                const input = ((ujn << 15) | u.__halfDigit(j + n - 1)) >>> 0;\n                qhat = (input / vn1) | 0;\n                let rhat = (input % vn1) | 0;\n                const vn2 = divisor.__halfDigit(n - 2);\n                const ujn2 = u.__halfDigit(j + n - 2);\n                while ((JSBI.__imul(qhat, vn2) >>> 0) > (((rhat << 16) | ujn2) >>> 0)) {\n                    qhat--;\n                    rhat += vn1;\n                    if (rhat > 0x7FFF)\n                        break;\n                }\n            }\n            // D4.\n            JSBI.__internalMultiplyAdd(divisor, qhat, 0, n2, qhatv);\n            let c = u.__inplaceSub(qhatv, j, n + 1);\n            if (c !== 0) {\n                c = u.__inplaceAdd(divisor, j, n);\n                u.__setHalfDigit(j + n, (u.__halfDigit(j + n) + c) & 0x7FFF);\n                qhat--;\n            }\n            if (wantQuotient) {\n                if (j & 1) {\n                    halfDigitBuffer = qhat << 15;\n                }\n                else {\n                    // TODO make this statically determinable\n                    q.__setDigit(j >>> 1, halfDigitBuffer | qhat);\n                }\n            }\n        }\n        if (wantRemainder) {\n            u.__inplaceRightShift(shift);\n            if (wantQuotient) {\n                return { quotient: q, remainder: u };\n            }\n            return u;\n        }\n        if (wantQuotient)\n            return q;\n        // TODO find a way to make this statically unreachable?\n        throw new Error('unreachable');\n    }\n    static __clz15(value) {\n        return JSBI.__clz30(value) - 15;\n    }\n    // TODO: work on full digits, like __inplaceSub?\n    __inplaceAdd(summand, startIndex, halfDigits) {\n        let carry = 0;\n        for (let i = 0; i < halfDigits; i++) {\n            const sum = this.__halfDigit(startIndex + i) +\n                summand.__halfDigit(i) +\n                carry;\n            carry = sum >>> 15;\n            this.__setHalfDigit(startIndex + i, sum & 0x7FFF);\n        }\n        return carry;\n    }\n    __inplaceSub(subtrahend, startIndex, halfDigits) {\n        const fullSteps = (halfDigits - 1) >>> 1;\n        let borrow = 0;\n        if (startIndex & 1) {\n            // this:   [..][..][..]\n            // subtr.:   [..][..]\n            startIndex >>= 1;\n            let current = this.__digit(startIndex);\n            let r0 = current & 0x7FFF;\n            let i = 0;\n            for (; i < fullSteps; i++) {\n                const sub = subtrahend.__digit(i);\n                const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - (sub >>> 15) - borrow;\n                borrow = (r0 >>> 15) & 1;\n            }\n            // Unrolling the last iteration gives a 5% performance benefit!\n            const sub = subtrahend.__digit(i);\n            const r15 = (current >>> 15) - (sub & 0x7FFF) - borrow;\n            borrow = (r15 >>> 15) & 1;\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            const subTop = sub >>> 15;\n            if (startIndex + i + 1 >= this.length) {\n                throw new RangeError('out of bounds');\n            }\n            if ((halfDigits & 1) === 0) {\n                current = this.__digit(startIndex + i + 1);\n                r0 = (current & 0x7FFF) - subTop - borrow;\n                borrow = (r0 >>> 15) & 1;\n                this.__setDigit(startIndex + subtrahend.length, (current & 0x3FFF8000) | (r0 & 0x7FFF));\n            }\n        }\n        else {\n            startIndex >>= 1;\n            let i = 0;\n            for (; i < subtrahend.length - 1; i++) {\n                const current = this.__digit(startIndex + i);\n                const sub = subtrahend.__digit(i);\n                const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n                borrow = (r0 >>> 15) & 1;\n                const r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n                this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n            }\n            const current = this.__digit(startIndex + i);\n            const sub = subtrahend.__digit(i);\n            const r0 = (current & 0x7FFF) - (sub & 0x7FFF) - borrow;\n            borrow = (r0 >>> 15) & 1;\n            let r15 = 0;\n            if ((halfDigits & 1) === 0) {\n                r15 = (current >>> 15) - (sub >>> 15) - borrow;\n                borrow = (r15 >>> 15) & 1;\n            }\n            this.__setDigit(startIndex + i, ((r15 & 0x7FFF) << 15) | (r0 & 0x7FFF));\n        }\n        return borrow;\n    }\n    __inplaceRightShift(shift) {\n        if (shift === 0)\n            return;\n        let carry = this.__digit(0) >>> shift;\n        const last = this.length - 1;\n        for (let i = 0; i < last; i++) {\n            const d = this.__digit(i + 1);\n            this.__setDigit(i, ((d << (30 - shift)) & 0x3FFFFFFF) | carry);\n            carry = d >>> shift;\n        }\n        this.__setDigit(last, carry);\n    }\n    static __specialLeftShift(x, shift, addDigit) {\n        const n = x.length;\n        const resultLength = n + addDigit;\n        const result = new JSBI(resultLength, false);\n        if (shift === 0) {\n            for (let i = 0; i < n; i++)\n                result.__setDigit(i, x.__digit(i));\n            if (addDigit > 0)\n                result.__setDigit(n, 0);\n            return result;\n        }\n        let carry = 0;\n        for (let i = 0; i < n; i++) {\n            const d = x.__digit(i);\n            result.__setDigit(i, ((d << shift) & 0x3FFFFFFF) | carry);\n            carry = d >>> (30 - shift);\n        }\n        if (addDigit > 0) {\n            result.__setDigit(n, carry);\n        }\n        return result;\n    }\n    static __leftShiftByAbsolute(x, y) {\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            throw new RangeError('BigInt too big');\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        const length = x.length;\n        const grow = bitsShift !== 0 &&\n            (x.__digit(length - 1) >>> (30 - bitsShift)) !== 0;\n        const resultLength = length + digitShift + (grow ? 1 : 0);\n        const result = new JSBI(resultLength, x.sign);\n        if (bitsShift === 0) {\n            let i = 0;\n            for (; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (; i < resultLength; i++) {\n                result.__setDigit(i, x.__digit(i - digitShift));\n            }\n        }\n        else {\n            let carry = 0;\n            for (let i = 0; i < digitShift; i++)\n                result.__setDigit(i, 0);\n            for (let i = 0; i < length; i++) {\n                const d = x.__digit(i);\n                result.__setDigit(i + digitShift, ((d << bitsShift) & 0x3FFFFFFF) | carry);\n                carry = d >>> (30 - bitsShift);\n            }\n            if (grow) {\n                result.__setDigit(length + digitShift, carry);\n            }\n            else {\n                if (carry !== 0)\n                    throw new Error('implementation bug');\n            }\n        }\n        return result.__trim();\n    }\n    static __rightShiftByAbsolute(x, y) {\n        const length = x.length;\n        const sign = x.sign;\n        const shift = JSBI.__toShiftAmount(y);\n        if (shift < 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        const digitShift = (shift / 30) | 0;\n        const bitsShift = shift % 30;\n        let resultLength = length - digitShift;\n        if (resultLength <= 0)\n            return JSBI.__rightShiftByMaximum(sign);\n        // For negative numbers, round down if any bit was shifted out (so that\n        // e.g. -5n >> 1n == -3n and not -2n). Check now whether this will happen\n        // and whether itc an cause overflow into a new digit. If we allocate the\n        // result large enough up front, it avoids having to do grow it later.\n        let mustRoundDown = false;\n        if (sign) {\n            const mask = (1 << bitsShift) - 1;\n            if ((x.__digit(digitShift) & mask) !== 0) {\n                mustRoundDown = true;\n            }\n            else {\n                for (let i = 0; i < digitShift; i++) {\n                    if (x.__digit(i) !== 0) {\n                        mustRoundDown = true;\n                        break;\n                    }\n                }\n            }\n        }\n        // If bitsShift is non-zero, it frees up bits, preventing overflow.\n        if (mustRoundDown && bitsShift === 0) {\n            // Overflow cannot happen if the most significant digit has unset bits.\n            const msd = x.__digit(length - 1);\n            const roundingCanOverflow = ~msd === 0;\n            if (roundingCanOverflow)\n                resultLength++;\n        }\n        let result = new JSBI(resultLength, sign);\n        if (bitsShift === 0) {\n            // Zero out any overflow digit (see \"roundingCanOverflow\" above).\n            result.__setDigit(resultLength - 1, 0);\n            for (let i = digitShift; i < length; i++) {\n                result.__setDigit(i - digitShift, x.__digit(i));\n            }\n        }\n        else {\n            let carry = x.__digit(digitShift) >>> bitsShift;\n            const last = length - digitShift - 1;\n            for (let i = 0; i < last; i++) {\n                const d = x.__digit(i + digitShift + 1);\n                result.__setDigit(i, ((d << (30 - bitsShift)) & 0x3FFFFFFF) | carry);\n                carry = d >>> bitsShift;\n            }\n            result.__setDigit(last, carry);\n        }\n        if (mustRoundDown) {\n            // Since the result is negative, rounding down means adding one to its\n            // absolute value. This cannot overflow.\n            result = JSBI.__absoluteAddOne(result, true, result);\n        }\n        return result.__trim();\n    }\n    static __rightShiftByMaximum(sign) {\n        if (sign) {\n            return JSBI.__oneDigit(1, true);\n        }\n        return JSBI.__zero();\n    }\n    static __toShiftAmount(x) {\n        if (x.length > 1)\n            return -1;\n        const value = x.__unsignedDigit(0);\n        if (value > JSBI.__kMaxLengthBits)\n            return -1;\n        return value;\n    }\n    static __toPrimitive(obj, hint = 'default') {\n        if (typeof obj !== 'object')\n            return obj;\n        if (obj.constructor === JSBI)\n            return obj;\n        if (typeof Symbol !== 'undefined' &&\n            typeof Symbol.toPrimitive === 'symbol') {\n            const exoticToPrim = obj[Symbol.toPrimitive];\n            if (exoticToPrim) {\n                const primitive = exoticToPrim(hint);\n                if (typeof primitive !== 'object')\n                    return primitive;\n                throw new TypeError('Cannot convert object to primitive value');\n            }\n        }\n        const valueOf = obj.valueOf;\n        if (valueOf) {\n            const primitive = valueOf.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        const toString = obj.toString;\n        if (toString) {\n            const primitive = toString.call(obj);\n            if (typeof primitive !== 'object')\n                return primitive;\n        }\n        throw new TypeError('Cannot convert object to primitive value');\n    }\n    static __toNumeric(value) {\n        if (JSBI.__isBigInt(value))\n            return value;\n        return +value;\n    }\n    static __isBigInt(value) {\n        return typeof value === 'object' && value !== null &&\n            value.constructor === JSBI;\n    }\n    static __truncateToNBits(n, x) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, x.sign);\n        const last = neededDigits - 1;\n        for (let i = 0; i < last; i++) {\n            result.__setDigit(i, x.__digit(i));\n        }\n        let msd = x.__digit(last);\n        if ((n % 30) !== 0) {\n            const drop = 32 - (n % 30);\n            msd = (msd << drop) >>> drop;\n        }\n        result.__setDigit(last, msd);\n        return result.__trim();\n    }\n    static __truncateAndSubFromPowerOfTwo(n, x, resultSign) {\n        const neededDigits = ((n + 29) / 30) | 0;\n        const result = new JSBI(neededDigits, resultSign);\n        let i = 0;\n        const last = neededDigits - 1;\n        let borrow = 0;\n        const limit = Math.min(last, x.length);\n        for (; i < limit; i++) {\n            const r = 0 - x.__digit(i) - borrow;\n            borrow = (r >>> 30) & 1;\n            result.__setDigit(i, r & 0x3FFFFFFF);\n        }\n        for (; i < last; i++) {\n            result.__setDigit(i, (-borrow & 0x3FFFFFFF) | 0);\n        }\n        let msd = last < x.length ? x.__digit(last) : 0;\n        const msdBitsConsumed = n % 30;\n        let resultMsd;\n        if (msdBitsConsumed === 0) {\n            resultMsd = 0 - msd - borrow;\n            resultMsd &= 0x3FFFFFFF;\n        }\n        else {\n            const drop = 32 - msdBitsConsumed;\n            msd = (msd << drop) >>> drop;\n            const minuendMsd = 1 << (32 - drop);\n            resultMsd = minuendMsd - msd - borrow;\n            resultMsd &= (minuendMsd - 1);\n        }\n        result.__setDigit(last, resultMsd);\n        return result.__trim();\n    }\n    // Digit helpers.\n    __digit(i) {\n        return this[i];\n    }\n    __unsignedDigit(i) {\n        return this[i] >>> 0;\n    }\n    __setDigit(i, digit) {\n        this[i] = digit | 0;\n    }\n    __setDigitGrow(i, digit) {\n        this[i] = digit | 0;\n    }\n    __halfDigitLength() {\n        const len = this.length;\n        if (this.__unsignedDigit(len - 1) <= 0x7FFF)\n            return len * 2 - 1;\n        return len * 2;\n    }\n    __halfDigit(i) {\n        return (this[i >>> 1] >>> ((i & 1) * 15)) & 0x7FFF;\n    }\n    __setHalfDigit(i, value) {\n        const digitIndex = i >>> 1;\n        const previous = this.__digit(digitIndex);\n        const updated = (i & 1) ? (previous & 0x7FFF) | (value << 15)\n            : (previous & 0x3FFF8000) | (value & 0x7FFF);\n        this.__setDigit(digitIndex, updated);\n    }\n    static __digitPow(base, exponent) {\n        let result = 1;\n        while (exponent > 0) {\n            if (exponent & 1)\n                result *= base;\n            exponent >>>= 1;\n            base *= base;\n        }\n        return result;\n    }\n    static __isOneDigitInt(x) {\n        return (x & 0x3FFFFFFF) === x;\n    }\n}\nJSBI.__kMaxLength = 1 << 25;\nJSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5;\n// Lookup table for the maximum number of bits required per character of a\n// base-N string representation of a number. To increase accuracy, the array\n// value is the actual value multiplied by 32. To generate this table:\n//\n// for (let i = 0; i <= 36; i++) {\n//   console.log(Math.ceil(Math.log2(i) * 32) + ',');\n// }\nJSBI.__kMaxBitsPerChar = [\n    0, 0, 32, 51, 64, 75, 83, 90, 96,\n    102, 107, 111, 115, 119, 122, 126, 128,\n    131, 134, 136, 139, 141, 143, 145, 147,\n    149, 151, 153, 154, 156, 158, 159, 160,\n    162, 163, 165, 166, // 33..36\n];\nJSBI.__kBitsPerCharTableShift = 5;\nJSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift;\nJSBI.__kConversionChars = '0123456789abcdefghijklmnopqrstuvwxyz'.split('');\nJSBI.__kBitConversionBuffer = new ArrayBuffer(8);\nJSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer);\nJSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\n// For IE11 compatibility.\n// Note that the custom replacements are tailored for JSBI's needs, and as\n// such are not reusable as general-purpose polyfills.\nJSBI.__clz30 = Math.clz32 ? function (x) {\n    return Math.clz32(x) - 2;\n} : function (x) {\n    if (x === 0)\n        return 30;\n    return 29 - (Math.log(x >>> 0) / Math.LN2 | 0) | 0;\n};\nJSBI.__imul = Math.imul || function (a, b) {\n    return (a * b) | 0;\n};\nexport default JSBI;\n//# sourceMappingURL=jsbi.js.map", "import { DEBUG } from './debug';\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nexport function MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    if (DEBUG) {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nexport function DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nexport function GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n//# sourceMappingURL=intrinsicclass.js.map", "// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nexport function CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nexport function HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nexport function GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nexport function SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n//# sourceMappingURL=slots.js.map", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport { CALENDAR_ID, ISO_YEAR, ISO_MONTH, ISO_DAY, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, HasSlot, SetSlot } from './slots';\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ES.ToString(idParam);\n        if (!IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        const duration = ES.ToTemporalDuration(durationParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const { days } = ES.BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'], 'day');\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalCalendar(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year']\n        ]);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n        return ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return ES.CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return ES.DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            ES.RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ES.ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ES.ISOYearString(isoYear);\n    const monthString = ES.ISODateTimePartString(isoMonth);\n    const dayString = ES.ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En\u2019\u014D\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            ES.RejectToRange(month, 1, largestMonth);\n            ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ES.ConstrainToRange(month, 1, largestMonth);\n            day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = ES.PrepareTemporalFields(date1Param, [['day'], ['month'], ['year']]);\n        const date2 = ES.PrepareTemporalFields(date2Param, [['day'], ['month'], ['year']]);\n        if (date1.year !== date2.year)\n            return ES.ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ES.ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ES.ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, month, day } = calendarDate;\n        const addedMonths = this.addMonthsCalendar({ year: year + years, month, day }, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = ES.DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month > 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n                    ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year \u2013 if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, largestMonth);\n                    ES.RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, largestMonth);\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = ES.CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = ES.PrepareTemporalFields(fieldsParam, [\n            ['day'],\n            ['era', undefined],\n            ['eraYear', undefined],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['year', undefined]\n        ]);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = ES.CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\nconst BUILTIN_CALENDAR_IDS = Object.keys(impl);\nexport function IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\n//# sourceMappingURL=calendar.js.map", "const ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectIs = Object.is;\nconst ReflectApply = Reflect.apply;\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { CreateSlots, GetSlot, HasSlot, SetSlot, EPOCHNANOSECONDS, TIMEZONE_ID, CALENDAR_ID, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, DATE_BRAND, YEAR_MONTH_BRAND, MONTH_DAY_BRAND, TIME_ZONE, CALENDAR, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS } from './slots';\nimport { IsBuiltinCalendar } from './calendar';\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = JSBI.multiply(JSBI.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nexport function IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nexport function ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nexport function ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nexport function ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nexport function ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nexport function ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // \u211D(value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = JSBI.divide(x, y);\n    const remainder = JSBI.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (JSBI.lessThan(x, ZERO))\n        return JSBI.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst ALLOWED_UNITS = [\n    'year',\n    'month',\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year'],\n    ['months', 'month'],\n    ['weeks', 'week'],\n    ['days', 'day'],\n    ['hours', 'hour'],\n    ['minutes', 'minute'],\n    ['seconds', 'second'],\n    ['milliseconds', 'millisecond'],\n    ['microseconds', 'microsecond'],\n    ['nanoseconds', 'nanosecond']\n];\nimport * as PARSE from './regex';\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nexport function IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nexport function IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nexport function IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nexport function IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = PARSE.zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\nfunction ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\nfunction ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\nfunction ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\nfunction ParseTemporalTimeString(isoString) {\n    const match = PARSE.time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\nfunction ParseTemporalYearMonthString(isoString) {\n    const match = PARSE.yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\nfunction ParseTemporalMonthDayString(isoString) {\n    const match = PARSE.monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\nfunction ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent) {\n            canonicalIdent = canonicalIdent.toString();\n            if (TestTimeZoneOffsetString(canonicalIdent))\n                return { offset: canonicalIdent };\n            return { ianaName: canonicalIdent };\n        }\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\nfunction ParseTemporalDurationString(isoString) {\n    const match = PARSE.duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ParseTemporalInstant(isoString) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n}\nexport function RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nexport function RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const props = ToPartialRecord(item, [\n        'days',\n        'hours',\n        'microseconds',\n        'milliseconds',\n        'minutes',\n        'months',\n        'nanoseconds',\n        'seconds',\n        'weeks',\n        'years'\n    ]);\n    if (!props)\n        throw new TypeError('invalid duration-like');\n    const { years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0 } = props;\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function ToLimitedTemporalDuration(item, disallowedProperties = []) {\n    let record;\n    if (IsObject(item)) {\n        record = ToTemporalDurationRecord(item);\n    }\n    else {\n        const str = ToString(item);\n        record = ParseTemporalDurationString(str);\n    }\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = record;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nexport function ToTemporalOverflow(options) {\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nexport function ToTemporalDisambiguation(options) {\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nexport function ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nexport function NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nexport function ToTemporalOffset(options, fallback) {\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nexport function ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nexport function ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nexport function ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nexport function ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nexport function ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nexport function ToSecondsStringPrecision(options) {\n    const smallestUnit = ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week', 'day', 'hour']);\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n        default: // fall through if option not given\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nexport function ToLargestTemporalUnit(options, fallback, disallowedStrings = [], autoValue) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const retval = GetOption(options, 'largestUnit', ['auto', ...allowed, ...singular.keys()], fallback);\n    if (retval === 'auto' && autoValue !== undefined)\n        return autoValue;\n    if (singular.has(retval)) {\n        return singular.get(retval);\n    }\n    return retval;\n}\nexport function ToSmallestTemporalUnit(options, fallback, disallowedStrings = []) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS.filter(([, sing]) => !disallowedStrings.includes(sing)));\n    const allowed = new Set(ALLOWED_UNITS);\n    for (const s of disallowedStrings) {\n        allowed.delete(s);\n    }\n    const value = GetOption(options, 'smallestUnit', [...allowed, ...singular.keys()], fallback);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nexport function ToTemporalDurationTotalUnit(options) {\n    // This AO is identical to ToSmallestTemporalUnit, except:\n    // - default is always `undefined` (caller will throw if omitted)\n    // - option is named `unit` (not `smallestUnit`)\n    // - all units are valid (no `disallowedStrings`)\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    const value = GetOption(options, 'unit', [...singular.values(), ...singular.keys()], undefined);\n    if (singular.has(value)) {\n        return singular.get(value);\n    }\n    return value;\n}\nexport function ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(relativeTo, fieldNames);\n        const dateOptions = ObjectCreate(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nexport function ValidateTemporalUnitRange(largestUnit, smallestUnit) {\n    if (ALLOWED_UNITS.indexOf(largestUnit) > ALLOWED_UNITS.indexOf(smallestUnit)) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n}\nexport function DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    const singular = new Map(SINGULAR_PLURAL_UNITS);\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0)\n            return singular.get(prop);\n    }\n    return 'nanosecond';\n}\nexport function LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (ALLOWED_UNITS.indexOf(unit1) > ALLOWED_UNITS.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nexport function ToPartialRecord(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    let any = false;\n    let result = {};\n    for (const property of fields) {\n        const value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                result[property] = BUILTIN_CASTS.get(property)(value);\n            }\n            else {\n                result[property] = value;\n            }\n        }\n    }\n    return any ? result : false;\n}\nexport function PrepareTemporalFields(bagParam, fieldsParam) {\n    // External callers are limited to specific types, but this function's\n    // implementation uses generic property types. The casts below (and at the\n    // end) convert to/from generic records.\n    const bag = bagParam;\n    const fields = fieldsParam;\n    const result = {};\n    let any = false;\n    for (const fieldRecord of fields) {\n        const [property, defaultValue] = fieldRecord;\n        let value = bag[property];\n        if (value === undefined) {\n            if (fieldRecord.length === 1) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = defaultValue;\n        }\n        else {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n        }\n        result[property] = value;\n    }\n    if (!any) {\n        throw new TypeError('no supported properties found');\n    }\n    if ((result['era'] === undefined) !==\n        (result['eraYear'] === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\n// field access in the following operations is intentionally alphabetical\nexport function ToTemporalDateFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalMonthDayFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalTimeRecord(bag) {\n    return PrepareTemporalFields(bag, [\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['nanosecond', 0],\n        ['second', 0]\n    ]);\n}\nexport function ToTemporalYearMonthFields(bag, fieldNames) {\n    const entries = [\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['year', undefined]\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nfunction ToTemporalZonedDateTimeFields(bag, fieldNames) {\n    const entries = [\n        ['day', undefined],\n        ['hour', 0],\n        ['microsecond', 0],\n        ['millisecond', 0],\n        ['minute', 0],\n        ['month', undefined],\n        ['monthCode', undefined],\n        ['nanosecond', 0],\n        ['second', 0],\n        ['year', undefined],\n        ['offset', undefined],\n        ['timeZone']\n    ];\n    // Add extra fields from the calendar at the end\n    fieldNames.forEach((fieldName) => {\n        if (!entries.some(([name]) => name === fieldName)) {\n            entries.push([fieldName, undefined]);\n        }\n    });\n    return PrepareTemporalFields(bag, entries);\n}\nexport function ToTemporalDate(itemParam, options = ObjectCreate(null)) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalDateFields(item, fieldNames);\n        return DateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nexport function InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = DateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function ToTemporalDateTime(item, options = ObjectCreate(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function ToTemporalDuration(item) {\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (IsObject(item)) {\n        if (IsTemporalDuration(item))\n            return item;\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ToTemporalDurationRecord(item));\n    }\n    else {\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ParseTemporalDurationString(ToString(item)));\n    }\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nexport function ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nexport function ToTemporalMonthDay(item, options = ObjectCreate(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = ToTemporalMonthDayFields(item, fieldNames);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return MonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    const canonicalOptions = ObjectCreate(null);\n    return MonthDayFromFields(calendar, result, canonicalOptions);\n}\nexport function ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nexport function ToTemporalYearMonth(item, options = ObjectCreate(null)) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = ToTemporalYearMonthFields(item, fieldNames);\n        return YearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    const canonicalOptions = ObjectCreate(null);\n    return YearMonthFromFields(calendar, result, canonicalOptions);\n}\nexport function InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nexport function ToTemporalZonedDateTime(item, options = ObjectCreate(null)) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = ToTemporalZonedDateTimeFields(item, fieldNames);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nexport function CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    if (DEBUG) {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nexport function CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, \u00B5s, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, \u00B5s, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, \u00B5s, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, \u00B5s);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, \u00B5s, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, \u00B5s, ns, calendar);\n    return result;\n}\nexport function CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nexport function CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nexport function CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nexport function GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush.call(result, name);\n    }\n    return result;\n}\nexport function CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nexport function CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nexport function CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nexport function CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nexport function CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nexport function CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nexport function CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nexport function CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nexport function CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nexport function CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nexport function CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nexport function CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nexport function CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nexport function ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nexport function CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nexport function ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nexport function DateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function YearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function MonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nexport function TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nexport function TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nexport function TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nexport function GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nexport function BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nexport function BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush.call(result, instant);\n    }\n    return result;\n}\nexport function ISOYearString(year) {\n    let yearString;\n    if (year < 1000 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `${year}`;\n    }\n    return yearString;\n}\nexport function ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nexport function TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nexport function TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return JSBI.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let \u00B5s = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, \u00B5s, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: \u00B5s,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, \u00B5s, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, \u00B5s, ns, 0);\n    let nsBigInt, \u00B5sBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: \u00B5sBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(\u00B5sBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nexport function TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nexport function TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nexport function TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nexport function TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nexport function ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nexport function GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n    ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n    ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n    if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = JSBI.toNumber(quotient);\n    let nanos = JSBI.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return JSBI.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nexport function GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n        rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nexport function GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n        leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nexport function GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n    if (JSBI.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = JSBI.add(ns, DAY_NANOS);\n    if (JSBI.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nexport function LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nexport function ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nexport function DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nexport function DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nexport function WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nexport function DurationSign(y, mon, w, d, h, min, s, ms, \u00B5s, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, \u00B5s, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = JSBI.BigInt(daysParam);\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n    const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n    const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n    const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n    const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n    const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n    return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n        return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = JSBI.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day');\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && JSBI.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = JSBI.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = JSBI.greaterThan(JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nexport function BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = JSBI.toNumber(hoursBigInt) * sign;\n    const minutes = JSBI.toNumber(minutesBigInt) * sign;\n    const seconds = JSBI.toNumber(secondsBigInt) * sign;\n    const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n    const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const addOptions = ObjectCreate(null);\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, addOptions, dateAdd);\n                    const untilOptions = ObjectCreate(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            const addOptions = ObjectCreate(null);\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                const addOptions = ObjectCreate(null);\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, addOptions, dateAdd);\n                const untilOptions = ObjectCreate(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n        default:\n            // no-op\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function CalculateOffsetShift(relativeTo, y, mon, w, d, h, min, s, ms, \u00B5s, ns) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, h, min, s, ms, \u00B5s, ns);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nexport function CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nexport function ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nexport function RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nexport function ValidateEpochNanoseconds(epochNanoseconds) {\n    if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nfunction RejectDuration(y, mon, w, d, h, min, s, ms, \u00B5s, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, \u00B5s, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, \u00B5s, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nexport function DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n                midSign = -CompareISODate(y1, m1, d1, mid.year, mid.month, mid.day);\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nexport function DifferenceTime(h1, min1, s1, ms1, \u00B5s1, ns1, h2, min2, s2, ms2, \u00B5s2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = \u00B5s2 - \u00B5s1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    deltaDays *= sign;\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = JSBI.subtract(ns2, ns1);\n    const remainder = JSBI.remainder(diff, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = JSBI.add(wholeDays, roundedRemainder);\n    const nanoseconds = JSBI.toNumber(JSBI.remainder(roundedDiff, THOUSAND));\n    const microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = JSBI.toNumber(JSBI.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, \u00B5s1, ns1, y2, mon2, d2, h2, min2, s2, ms2, \u00B5s2, ns2, calendar, largestUnit, options = ObjectCreate(null)) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, \u00B5s1, ns1, h2, min2, s2, ms2, \u00B5s2, ns2);\n    const timeSign = DurationSign(0, 0, 0, deltaDays, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 + deltaDays));\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = { ...options, largestUnit: dateLargestUnit };\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = JSBI.subtract(ns2, ns1);\n    if (JSBI.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nexport function AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, \u00B5s2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, \u00B5s2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, \u00B5s1 + \u00B5s2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const firstAddOptions = ObjectCreate(null);\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, firstAddOptions, dateAdd);\n        const secondAddOptions = ObjectCreate(null);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, secondAddOptions, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, \u00B5s1 + \u00B5s2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, \u00B5s2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function AddInstant(epochNanoseconds, h, min, s, ms, \u00B5s, ns) {\n    let sum = ZERO;\n    sum = JSBI.add(sum, JSBI.BigInt(ns));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(\u00B5s), THOUSAND));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n    const result = JSBI.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nexport function AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nexport function AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, \u00B5s, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, \u00B5s, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, \u00B5s, ns);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, JSBI.BigInt(increment));\n    if (JSBI.equal(remainder, ZERO))\n        return quantity;\n    const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (JSBI.toNumber(abs(JSBI.multiply(remainder, JSBI.BigInt(2)))) >= increment) {\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            }\n            break;\n    }\n    return JSBI.multiply(quotient, JSBI.BigInt(increment));\n}\nexport function RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = JSBI.remainder(epochNs, JSBI.BigInt(86400e9));\n    if (JSBI.lessThan(remainder, ZERO))\n        remainder = JSBI.add(remainder, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return JSBI.add(wholeDays, roundedRemainder);\n}\nexport function RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = JSBI.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const options = ObjectCreate(null);\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, options);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nexport function MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nexport function AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n    if (JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = JSBI.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate(null);\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const thirdAddOptions = ObjectCreate(null);\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, thirdAddOptions, dateAdd);\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            const fourthAddOptions = ObjectCreate(null);\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, fourthAddOptions, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const firstAddOptions = ObjectCreate(null);\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, firstAddOptions, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const secondAddOptions = ObjectCreate(null);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, secondAddOptions, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = JSBI.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: JSBI.toNumber(nanoseconds),\n        total\n    };\n}\nexport function CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nexport function ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nexport function ToBigInt(arg) {\n    if (arg instanceof JSBI) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return JSBI.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds = (() => {\n    let ns = JSBI.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = JSBI.BigInt(Date.now());\n        const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n        ns = JSBI.divide(ms, MILLION);\n        if (JSBI.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (JSBI.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nexport function SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nexport function ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nexport function GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nexport function CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${property} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = JSBI.BigInt(leftParam);\n    let right = JSBI.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n        const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n//# sourceMappingURL=ecmascript.js.map", "const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nexport const zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nexport const time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nexport const yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nexport const monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n//# sourceMappingURL=regex.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { GetSlot, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, TIME_ZONE } from './slots';\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ES.ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst properties = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    properties.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, properties);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nexport const DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options and the lib\n    // types for resolved options are less restrictive than the types for options.\n    // For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    if (options['dateStyle'] || options['timeStyle']) {\n        // Unfortunately, Safari's resolvedOptions include parameters that will\n        // cause errors at runtime if passed along with\n        // dateStyle or timeStyle options as per\n        // https://tc39.es/proposal-intl-datetime-style/#table-datetimeformat-components.\n        // This has been fixed in newer versions of Safari:\n        // https://bugs.webkit.org/show_bug.cgi?id=231041\n        delete options['weekday'];\n        delete options['era'];\n        delete options['year'];\n        delete options['month'];\n        delete options['day'];\n        delete options['hour'];\n        delete options['minute'];\n        delete options['second'];\n        delete options['timeZoneName'];\n        delete options['hourCycle'];\n        delete options['hour12'];\n        delete options['dayPeriod'];\n    }\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (ES.IsTemporalDate(obj) ||\n        ES.IsTemporalTime(obj) ||\n        ES.IsTemporalDateTime(obj) ||\n        ES.IsTemporalZonedDateTime(obj) ||\n        ES.IsTemporalYearMonth(obj) ||\n        ES.IsTemporalMonthDay(obj) ||\n        ES.IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y))\n        return false;\n    if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y))\n        return false;\n    if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y))\n        return false;\n    if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y))\n        return false;\n    if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y))\n        return false;\n    if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y))\n        return false;\n    if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (ES.IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (ES.IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (ES.IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (ES.IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (ES.IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (ES.IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ES.ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (ES.IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n//# sourceMappingURL=intl.js.map", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\nconst DISALLOWED_UNITS = ['year', 'month', 'week', 'day'];\nconst MAX_DIFFERENCE_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nexport class Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ES.ToBigInt(epochNanoseconds);\n        ES.ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        if (DEBUG) {\n            const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = ES.AddInstant(GetSlot(this, EPOCHNANOSECONDS), hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        return new Instant(ns);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(temporalDurationLike, ['years', 'months', 'weeks', 'days']);\n        const ns = ES.AddInstant(GetSlot(this, EPOCHNANOSECONDS), -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n        return new Instant(ns);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(this, EPOCHNANOSECONDS);\n        const twons = GetSlot(other, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('second', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n        const onens = GetSlot(other, EPOCHNANOSECONDS);\n        const twons = GetSlot(this, EPOCHNANOSECONDS);\n        let { seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n        let hours, minutes;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ES.ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ES.ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ES.ToTemporalTimeZone(item);\n        const calendar = ES.GetISO8601Calendar();\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ES.ToNumber(epochSecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (ES.IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ES.ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalInstant(oneParam);\n        const two = ES.ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(oneNs, twoNs))\n            return -1;\n        if (JSBI.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n//# sourceMappingURL=instant.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst DISALLOWED_UNITS = ['hour', 'minute', 'second', 'millisecond', 'microsecond', 'nanosecond'];\nexport class PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalDateLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ES.ToTemporalDateFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalDateFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.DateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToTemporalDuration(temporalDurationLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        const result = ES.CalendarDateUntil(calendar, this, other, untilOptions);\n        if (smallestUnit === 'day' && roundingIncrement === 1)\n            return result;\n        let { years, months, weeks, days } = result;\n        ({ years, months, weeks, days } = ES.RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, this));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'day', DISALLOWED_UNITS);\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const untilOptions = { ...options, largestUnit };\n        let { years, months, weeks, days } = ES.CalendarDateUntil(calendar, this, other, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'day' && roundingIncrement === 1) {\n            return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months, weeks, days } = ES.RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), this));\n        return new Duration(-years, -months, -weeks, -days, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (ES.IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ES.ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ES.ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ES.ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDate(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n//# sourceMappingURL=plaindate.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nexport class PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ES.ToIntegerThrowOnInfinity(hourParam);\n        const minute = ES.ToIntegerThrowOnInfinity(minuteParam);\n        const second = ES.ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ES.ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ES.ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ES.ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ES.ToPartialRecord(temporalDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ES.ToTemporalDateTimeFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalDateTimeFields(fields, fieldNames);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = ES.TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('day', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceISODateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n        const relativeTo = ES.TemporalDateTimeToDate(this);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), relativeTo));\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDateTime(oneParam);\n        const two = ES.ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n//# sourceMappingURL=plaindatetime.js.map", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ES.ToIntegerWithoutRounding(yearsParam);\n        const months = ES.ToIntegerWithoutRounding(monthsParam);\n        const weeks = ES.ToIntegerWithoutRounding(weeksParam);\n        const days = ES.ToIntegerWithoutRounding(daysParam);\n        const hours = ES.ToIntegerWithoutRounding(hoursParam);\n        const minutes = ES.ToIntegerWithoutRounding(minutesParam);\n        const seconds = ES.ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ES.ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ES.ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ES.ToIntegerWithoutRounding(nanosecondsParam);\n        const sign = ES.DurationSign(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        for (const prop of [years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds]) {\n            if (!Number.isFinite(prop))\n                throw new RangeError('infinite values not allowed as duration fields');\n            const propSign = Math.sign(prop);\n            if (propSign !== 0 && propSign !== sign)\n                throw new RangeError('mixed-sign values not allowed as duration fields');\n        }\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ES.ToPartialRecord(durationLike, [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(other);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    subtract(other, optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.ToLimitedTemporalDuration(other);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.AddDuration(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS), -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = ES.DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        let smallestUnit = ES.ToSmallestTemporalUnit(options, undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ES.ToLargestTemporalUnit(options, undefined);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('unit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const unit = ES.ToTemporalDurationTotalUnit(options);\n        if (unit === undefined)\n            throw new RangeError('unit option is required');\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return ES.TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (ES.IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ES.ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ES.ToTemporalDuration(oneParam);\n        const two = ES.ToTemporalDuration(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const \u00B5s1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const \u00B5s2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1, h1, min1, s1, ms1, \u00B5s1, ns1);\n        const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2, h2, min2, s2, ms2, \u00B5s2, ns2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, \u00B5s1, ns1, shift1);\n        const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, \u00B5s2, ns2, shift2);\n        return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n//# sourceMappingURL=duration.js.map", "import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nexport class PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ES.ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalMonthDayLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalMonthDayFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.MonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, receiverFieldNames);\n        const inputFieldNames = ES.CalendarFields(calendar, ['year']);\n        const inputEntries = [['year', undefined]];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([fieldName, undefined]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = ES.PrepareTemporalFields(item, inputEntries);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalMonthDay(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ES.ToTemporalMonthDay(item, options);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n//# sourceMappingURL=plainmonthday.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.GetISO8601Calendar();\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(ES.GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return ES.SystemTimeZone();\n};\nexport const Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n//# sourceMappingURL=now.js.map", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectAssign = Object.assign;\nconst DISALLOWED_UNITS = ['year', 'month', 'week', 'day'];\nconst MAX_INCREMENTS = {\n    hour: 24,\n    minute: 60,\n    second: 60,\n    millisecond: 1000,\n    microsecond: 1000,\n    nanosecond: 1000\n};\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ES.ISODateTimePartString(hour);\n    const minuteString = ES.ISODateTimePartString(minute);\n    const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nexport class PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ES.ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ES.ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ES.ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ES.ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ES.ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ES.ToIntegerThrowOnInfinity(isoNanosecondParam);\n        ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, ES.GetISO8601Calendar());\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const props = ES.ToPartialRecord(temporalTimeLike, [\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'nanosecond',\n            'second'\n        ]);\n        if (!props) {\n            throw new TypeError('invalid time-like');\n        }\n        const fields = ES.ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, props);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.AddTime(hour, minute, second, millisecond, microsecond, nanosecond, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'hour');\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceTime(GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'hour');\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond', DISALLOWED_UNITS);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceTime(GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.RoundDuration(0, 0, 0, 0, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode)));\n        hours = -hours;\n        minutes = -minutes;\n        seconds = -seconds;\n        milliseconds = -milliseconds;\n        microseconds = -microseconds;\n        nanoseconds = -nanoseconds;\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, DISALLOWED_UNITS);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ES.ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        if (ES.IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ES.ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalTime(oneParam);\n        const two = ES.ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n//# sourceMappingURL=plaintime.js.map", "import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { TIMEZONE_ID, EPOCHNANOSECONDS, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            return ES.ParseTimeZoneOffsetString(id);\n        }\n        return ES.GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        return ES.BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = ES.GetISO8601Calendar()) {\n        const instant = ES.ToTemporalInstant(instantParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        return ES.BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            const epochNs = ES.GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ES.ParseTimeZoneOffsetString(id);\n            return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = ES.GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalTimeZone(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n//# sourceMappingURL=timezone.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nconst DISALLOWED_UNITS = [\n    'week',\n    'day',\n    'hour',\n    'minute',\n    'second',\n    'millisecond',\n    'microsecond',\n    'nanosecond'\n];\nexport class PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = ES.GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISODay = ES.ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ES.ToPartialRecord(temporalYearMonthLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.ToTemporalYearMonthFields(fields, fieldNames);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.YearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const sign = ES.DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ES.ToPositiveInteger(ES.CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = ES.DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = ES.CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ES.ToTemporalYearMonthFields(addedDate, fieldNames);\n        return ES.YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        let duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n        let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        ({ days } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const sign = ES.DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n        const day = sign < 0 ? ES.ToPositiveInteger(ES.CalendarDaysInMonth(calendar, this)) : 1;\n        const startDate = ES.DateFromFields(calendar, { ...fields, day });\n        const optionsCopy = { ...options };\n        const addedDate = ES.CalendarDateAdd(calendar, startDate, { ...duration, days }, options);\n        const addedDateFields = ES.ToTemporalYearMonthFields(addedDate, fieldNames);\n        return ES.YearMonthFromFields(calendar, addedDateFields, optionsCopy);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ES.ToString(calendar);\n        const otherCalendarID = ES.ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ES.ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = ES.DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = ES.DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        const result = ES.CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        if (smallestUnit === 'month' && roundingIncrement === 1)\n            return result;\n        let { years, months } = result;\n        ({ years, months } = ES.RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarID = ES.ToString(calendar);\n        const otherCalendarID = ES.ToString(otherCalendar);\n        if (calendarID !== otherCalendarID) {\n            throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'month', DISALLOWED_UNITS);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', DISALLOWED_UNITS, 'year');\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, undefined, false);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const otherFields = ES.ToTemporalYearMonthFields(other, fieldNames);\n        const thisFields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        const otherDate = ES.DateFromFields(calendar, { ...otherFields, day: 1 });\n        const thisDate = ES.DateFromFields(calendar, { ...thisFields, day: 1 });\n        const untilOptions = { ...options, largestUnit };\n        let { years, months } = ES.CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        if (smallestUnit === 'month' && roundingIncrement === 1) {\n            return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n        ({ years, months } = ES.RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, ES.NegateTemporalRoundingMode(roundingMode), thisDate));\n        return new Duration(-years, -months, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, receiverFieldNames);\n        const inputFieldNames = ES.CalendarFields(calendar, ['day']);\n        const inputEntries = [['day']];\n        // Add extra fields from the calendar at the end\n        inputFieldNames.forEach((fieldName) => {\n            if (!inputEntries.some(([name]) => name === fieldName)) {\n                inputEntries.push([\n                    fieldName,\n                    undefined\n                ]); // Make TS ignore extra fields\n            }\n        });\n        const inputFields = ES.PrepareTemporalFields(item, inputEntries);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        const mergedEntries = [];\n        mergedFieldNames.forEach((fieldName) => {\n            if (!mergedEntries.some(([name]) => name === fieldName)) {\n                mergedEntries.push([fieldName, undefined]);\n            }\n        });\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedEntries);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.DateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalYearMonth(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ES.ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalYearMonth(oneParam);\n        const two = ES.ToTemporalYearMonth(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n//# sourceMappingURL=plainyearmonth.js.map", "import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, EPOCHNANOSECONDS, ISO_HOUR, INSTANT, ISO_DAY, ISO_MONTH, ISO_YEAR, ISO_MICROSECOND, ISO_MILLISECOND, ISO_MINUTE, ISO_NANOSECOND, ISO_SECOND, TIME_ZONE, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO } from './ecmascript';\nconst ArrayPrototypePush = Array.prototype.push;\nexport class ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = ES.GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const offset = ES.ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        ArrayPrototypePush.call(fieldNames, 'offset');\n        const props = ES.ToPartialRecord(temporalZonedDateTimeLike, fieldNames);\n        if (!props) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        // Unlike ToTemporalZonedDateTimeFields, the offset property will be required.\n        const entries = [\n            ['day', undefined],\n            ['hour', 0],\n            ['microsecond', 0],\n            ['millisecond', 0],\n            ['minute', 0],\n            ['month', undefined],\n            ['monthCode', undefined],\n            ['nanosecond', 0],\n            ['second', 0],\n            ['year', undefined],\n            ['offset'],\n            ['timeZone']\n        ];\n        // Add extra fields from the calendar at the end\n        fieldNames.forEach((fieldName) => {\n            if (!entries.some(([name]) => name === fieldName)) {\n                entries.push([fieldName, undefined]);\n            }\n        });\n        let fields = ES.PrepareTemporalFields(this, entries);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, entries);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam == undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = ES.AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToLimitedTemporalDuration(temporalDurationLike);\n        const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n        const options = ES.GetOptionsObject(optionsParam);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const epochNanoseconds = ES.AddZonedDateTime(GetSlot(this, INSTANT), timeZone, calendar, -years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds, options);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    until(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!ES.TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    since(otherParam, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const otherCalendar = GetSlot(other, CALENDAR);\n        const calendarId = ES.ToString(calendar);\n        const otherCalendarId = ES.ToString(otherCalendar);\n        if (calendarId !== otherCalendarId) {\n            throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n        }\n        const options = ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, 'nanosecond');\n        const defaultLargestUnit = ES.LargerOfTwoTemporalUnits('hour', smallestUnit);\n        const largestUnit = ES.ToLargestTemporalUnit(options, 'auto', [], defaultLargestUnit);\n        ES.ValidateTemporalUnitRange(largestUnit, smallestUnit);\n        let roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        roundingMode = ES.NegateTemporalRoundingMode(roundingMode);\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        const ns1 = GetSlot(this, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n        let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = ES.DifferenceInstant(ns1, ns2, roundingIncrement, smallestUnit, roundingMode));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            const timeZone = GetSlot(this, TIME_ZONE);\n            if (!ES.TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n                throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                    'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n            }\n            const untilOptions = { ...options, largestUnit };\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, this));\n        }\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(-years, -months, -weeks, -days, -hours, -minutes, -seconds, -milliseconds, -microseconds, -nanoseconds);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.ToSmallestTemporalUnit(options, undefined, ['year', 'month', 'week']);\n        if (smallestUnit === undefined)\n            throw new RangeError('smallestUnit is required');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (JSBI.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        JSBI.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two)))\n            return false;\n        if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const showTimeZone = ES.ToShowTimeZoneNameOption(options);\n        const showOffset = ES.ToShowOffsetOption(options);\n        return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.ToTemporalYearMonthFields(this, fieldNames);\n        return ES.YearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.ToTemporalMonthDayFields(this, fieldNames);\n        return ES.MonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: ES.BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalZonedDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            ES.ToTemporalDisambiguation(options);\n            ES.ToTemporalOffset(options, 'reject');\n            return ES.CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalZonedDateTime(oneParam);\n        const two = ES.ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return -1;\n        if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n//# sourceMappingURL=zoneddatetime.js.map", "import { Instant } from './instant';\nimport JSBI from 'jsbi';\nimport * as ES from './ecmascript';\nimport { MILLION } from './ecmascript';\nexport function toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n    return new Instant(ES.ToBigInt(epochNanoseconds));\n}\n//# sourceMappingURL=legacydate.js.map", "// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Temporal.Instant,\n    Temporal.Calendar,\n    Temporal.PlainDate,\n    Temporal.PlainDateTime,\n    Temporal.Duration,\n    Temporal.PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    Temporal.PlainTime,\n    Temporal.TimeZone,\n    Temporal.PlainYearMonth,\n    Temporal.ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\nexport { Temporal, Intl, toTemporalInstant };\n//# sourceMappingURL=index.js.map", "import {Temporal} from \"@js-temporal/polyfill\";\nconst api = \"http://localhost:3000/api/v1\"\nlet countdowns = []\nlet data_needs_update = true\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n    updateDateField()\n    updateTimezoneField()\n\n    document.querySelector(\"#year-input\").addEventListener(\"change\", updateDateField)\n    document.querySelector(\"#month-select\").addEventListener(\"change\", updateDateField)\n    document.querySelector(\"#submit-button\").addEventListener(\"click\", submitCountdownForm)\n    setTimeout(fetchCountdowns, 100)\n    setTimeout(updateCountdownList, 50)\n})\n\nasync function submitCountdownForm() {\n    const title = document.querySelector(\"#title-input\").value\n    const description = document.querySelector(\"#description-input\").value\n    const createdBy = document.querySelector(\"#name-input\").value\n    const createdDate = Temporal.Now.zonedDateTimeISO()\n    const targetDate = (() => {\n        const year = document.querySelector(\"#year-input\").value\n        const month = document.querySelector(\"#month-select\").value\n        const day = document.querySelector(\"#date-select\").value\n        const [hour, minute] = document.querySelector(\"#time-input\").value.split(\":\")\n        const timeZone = document.querySelector(\"#timezone-select\").value\n\n        return Temporal.ZonedDateTime.from({year, month, day, hour, minute, timeZone})\n    })()\n\n    const body = JSON.stringify({title, description, createdBy, createdDate, targetDate})\n    const method = \"post\"\n    const headers = new Headers()\n    headers.set(\"Content-Type\", \"application/json\")\n\n    fetch(\n        `${api}/countdowns`,\n        {method, headers, body}\n    ).then(() => { data_needs_update = true })\n}\n\n\nfunction updateDateField() {\n    const date_select = document.querySelector(\"#date-select\")\n\n    const year = document.querySelector(\"#year-input\").value\n    const month = document.querySelector(\"#month-select\").value\n    const partial_date = Temporal.PlainYearMonth.from({year, month})\n\n    date_select.innerHTML = \"\"\n    for (let i = 1; i <= partial_date.daysInMonth; i++) {\n        date_select.innerHTML += `<option value=\"${i}\">${i}</option>`\n    }\n}\n\nfunction updateTimezoneField() {\n    const timezones = Intl.supportedValuesOf(\"timeZone\")\n        .reduce((prev, curr) => {\n            const timezones = {...prev}\n\n            if (!curr.includes(\"/\")) {\n                timezones[curr] = curr\n                return timezones\n            }\n\n            const [region, place] = curr.split(\"/\")\n            if (timezones[region] === undefined)\n                timezones[region] = {}\n\n            timezones[region][place] = curr\n            return timezones\n        }, {})\n\n    const options = Object.entries(timezones).map(([region, place]) => {\n        if (typeof place === \"string\") {\n            return `<option value=\"${place}\">${place}</option>`\n        }\n\n        const places = Object.entries(place).map(([place, timezone]) => {\n            return `<option value=\"${timezone}\">${place}</option>`\n        })\n\n        return `<optgroup label=\"${region}\">${places.join(\"\")}</optgroup>`\n    }).join(\"\")\n\n\n    document.querySelector(\"#timezone-select\").innerHTML = options\n}\n\nfunction updateCountdownList() {\n    const countdownList = document.querySelector(\"#countdown-list\")\n\n    countdownList.innerHTML = \"\"\n    countdowns.forEach(countdown => {\n        const countdownElement = createCountdown(countdown)\n        countdownList.innerHTML += countdownElement\n    })\n    setTimeout(updateCountdownList, 50)\n}\n\nasync function fetchCountdowns() {\n    if (!data_needs_update) {\n        setTimeout(fetchCountdowns, 100)\n        return\n    }\n\n    const response = await fetch(\n        `${api}/countdowns`,\n        {method: \"get\"}\n    )\n    const json = await response.json()\n    countdowns = json.map( countdown => {\n        return {\n            title: countdown.title,\n            description: countdown.description,\n            createdBy: countdown.createdBy,\n            createdDate: Temporal.ZonedDateTime.from(countdown.createdDate),\n            targetDate: Temporal.ZonedDateTime.from(countdown.targetDate)\n        }\n    })\n\n    data_needs_update = false\n    setTimeout(fetchCountdowns, 100)\n}\n\nfunction createCountdown(countdown) {\n    const userDateTimeOptions = Intl.DateTimeFormat().resolvedOptions()\n    const durationFormatter = new Intl.RelativeTimeFormat(\"da\", {numeric: \"auto\", style: \"long\"})\n\n    const now = Temporal.Now.zonedDateTimeISO(userDateTimeOptions.timeZone)\n\n    const created = Temporal.ZonedDateTime.from(countdown.createdDate)\n    const sinceCreated = now.until(created)\n\n    const target = Temporal.ZonedDateTime.from(countdown.targetDate)\n    const untilTarget = now.until(target)\n\n    return `<div class=\"flex flex-col flex-shrink flex-grow p-3 md:basis-full lg:basis-6/12 xl:basis-4/12 gap-1 items-center rounded-3xl bg-blue-500 text-white\">\n                <span>${countdown.title} ${durationFormatter.format(Math.ceil(untilTarget.total(\"seconds\")), \"seconds\")}</span>\n                <span>${countdown.description}</span>\n                <span>Oprettet af ${countdown.createdBy}, ${durationFormatter.format(Math.ceil(sinceCreated.total(\"seconds\")), \"seconds\")}.</span>\n            </div>`\n}\n\n"],
  "mappings": "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",
  "names": ["Math", "imul", "clz32", "JSBI", "abs", "max", "floor", "length", "sign", "i", "_", "a", "u", "setPrototypeOf", "prototype", "__kMaxLength", "RangeError", "g", "e", "c", "l", "result", "B", "digit", "t", "push", "toString", "join", "radix", "__toStringBasePowerOfTwo", "__toStringGeneric", "Error", "newLength", "last", "pop", "__clz30", "__digit", "multiplier", "summand", "mLow", "mHigh", "carry", "high", "d", "dLow", "dHigh", "pLow", "__imul", "pMid1", "pMid2", "pHigh", "v", "o", "__setDigit", "startIndex", "halfDigits", "sum", "__halfDigit", "__setHalfDigit", "subtrahend", "borrow", "current", "r0", "sub", "r15", "n", "D", "shift", "len", "__unsignedDigit", "value", "digitIndex", "previous", "updated", "arg", "Number", "isFinite", "__zero", "__isOneDigitInt", "__oneDigit", "__fromDouble", "__fromString", "SyntaxError", "_typeof", "constructor", "primitive", "__toPrimitive", "BigInt", "TypeError", "x", "xLength", "xMsd", "msdLeadingZeros", "xBitLength", "exponent", "currentDigit", "mantissaHigh", "r", "mantissaHighBitsUnset", "mantissaLow", "mantissaLowBitsUnset", "h", "b", "rounding", "__decideRounding", "signBit", "__kBitConversionInts", "__kBitConversionDouble", "__copy", "__absoluteSubOne", "__trim", "__absoluteAddOne", "y", "unaryMinus", "expValue", "__kMaxLengthBits", "neededDigits", "__initializeDigits", "msd", "runningSquare", "multiply", "resultLength", "__clzmsd", "__multiplyAccumulate", "__absoluteCompare", "quotient", "resultSign", "divisor", "__absoluteDivSmall", "__absoluteDivLarge", "remainderDigit", "__absoluteModSmall", "remainder", "__absoluteAdd", "__absoluteSub", "__rightShiftByAbsolute", "__leftShiftByAbsolute", "__compareToBigInt", "equal", "__absoluteAnd", "y1", "__absoluteOr", "__absoluteAndNot", "__absoluteXor", "neededLength", "topDigit", "compareDigit", "__truncateToNBits", "__truncateAndSubFromPowerOfTwo", "bitsInTopDigit", "__toNumeric", "__isBigInt", "add", "__compare", "EQ", "__equalToNumber", "dataview", "byteOffset", "littleEndian", "asIntN", "DataViewGetBigUint64", "getUint32", "low", "s", "DataViewSetBigUint64", "asUintN", "d1", "setUint32", "mantissaBitsUnset", "topUnconsumedBit", "mask", "rawExponent", "digits", "kMantissaHighTopBit", "msdTopBit", "remainingMantissaBits", "string", "cursor", "charCodeAt", "__isWhitespace", "chars", "bitsPerChar", "__kMaxBitsPerChar", "roundup", "__kBitsPerCharTableMultiplier", "bitsMin", "__kBitsPerCharTableShift", "limDigit", "limAlpha", "parts", "partsBits", "done", "part", "bits", "f", "p", "__fillFromParts", "charsSoFar", "S", "k", "m", "I", "digitsSoFar", "__inplaceMultiplyAdd", "bitsInDigit", "partBits", "charMask", "charsRequired", "Array", "pos", "availableBits", "newDigit", "__kConversionChars", "consumedBits", "isRecursiveCall", "bitLength", "maxBitsPerChar", "minBitsPerChar", "secondHalf", "secondHalfChars", "conqueror", "exponentiate", "input", "divisionResult", "firstHalf", "leftNegative", "bothNegative", "xSign", "__unequalSign", "__absoluteGreater", "__absoluteLess", "ySign", "yAbs", "xDigit", "__compareToDouble", "yBitLength", "compareMantissa", "op", "__comparisonResultToBool", "__compareToNumber", "inputLength", "__setDigitGrow", "yLength", "numPairs", "tmp", "tmpLength", "diff", "multiplicand", "accumulator", "accumulatorIndex", "m2Low", "m2High", "acc", "m1", "m1Low", "m1High", "rLow", "rMid1", "rMid2", "rHigh", "source", "factor", "rx", "ry", "upperHalf", "lowerHalf", "dividend", "wantQuotient", "wantRemainder", "__halfDigitLength", "n2", "q", "qhatv", "__clz15", "__specialLeftShift", "vn1", "halfDigitBuffer", "j", "qhat", "ujn", "rhat", "vn2", "ujn2", "__internalMultiplyAdd", "__inplaceSub", "__inplaceAdd", "__inplaceRightShift", "addDigit", "__toShiftAmount", "digitShift", "bitsShift", "grow", "__rightShiftByMaximum", "mustRoundDown", "obj", "hint", "Symbol", "toPrimitive", "exoticToPrim", "valueOf", "call", "drop", "min", "limit", "resultMsd", "msdBitsConsumed", "minuendMsd", "base", "ArrayBuffer", "Float64Array", "__kBitConversionBuffer", "Int32Array", "LN2", "log", "INTRINSICS", "MakeIntrinsicClass", "Class", "name", "Object", "defineProperty", "prototype", "Symbol", "toStringTag", "value", "writable", "enumerable", "configurable", "prop", "getOwnPropertyNames", "desc", "getOwnPropertyDescriptor", "DefineIntrinsic", "key", "Error", "GetIntrinsic", "intrinsic", "EPOCHNANOSECONDS", "TIMEZONE_ID", "ISO_YEAR", "ISO_MONTH", "ISO_DAY", "ISO_HOUR", "ISO_MINUTE", "ISO_SECOND", "ISO_MILLISECOND", "ISO_MICROSECOND", "ISO_NANOSECOND", "CALENDAR", "INSTANT", "TIME_ZONE", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "MILLISECONDS", "MICROSECONDS", "NANOSECONDS", "CALENDAR_ID", "slots", "WeakMap", "CreateSlots", "container", "set", "create", "GetSlots", "get", "HasSlot", "ids", "myslots", "reduce", "all", "id", "GetSlot", "TypeError", "SetSlot", "ArrayIncludes", "Array", "includes", "ArrayPrototypePush", "push", "IntlDateTimeFormat", "globalThis", "Intl", "DateTimeFormat", "ArraySort", "sort", "MathAbs", "Math", "abs", "MathFloor", "floor", "ObjectEntries", "entries", "ObjectKeys", "keys", "impl", "Calendar", "constructor", "idParam", "arguments", "length", "RangeError", "ES.ToString", "IsBuiltinCalendar", "this", "ES.IsTemporalCalendar", "dateFromFields", "fields", "optionsParam", "ES.IsObject", "options", "ES.GetOptionsObject", "yearMonthFromFields", "monthDayFromFields", "fieldsArray", "allowed", "Set", "has", "delete", "call", "mergeFields", "additionalFields", "dateAdd", "dateParam", "durationParam", "date", "ES.ToTemporalDate", "duration", "ES.ToTemporalDuration", "overflow", "ES.ToTemporalOverflow", "days", "ES.BalanceDuration", "dateUntil", "oneParam", "twoParam", "one", "two", "largestUnit", "ES.ToLargestTemporalUnit", "years", "months", "weeks", "year", "ES.IsTemporalYearMonth", "month", "ES.IsTemporalMonthDay", "monthCode", "day", "era", "eraYear", "dayOfWeek", "dayOfYear", "weekOfYear", "daysInWeek", "daysInMonth", "daysInYear", "monthsInYear", "inLeapYear", "toString", "toJSON", "from", "item", "ES.ToTemporalCalendar", "monthCodeNumberPart", "startsWith", "slice", "isNaN", "buildMonthCode", "leap", "padStart", "resolveNonLunisolarMonth", "calendarDate", "monthsPerYear", "ES.RejectToRange", "ES.ConstrainToRange", "numberPart", "fieldsParam", "calendar", "ES.PrepareTemporalFields", "undefined", "ES.RegulateISODate", "ES.CreateTemporalDate", "RegulateISOYearMonth", "yearParam", "monthParam", "referenceISODay", "RejectISODate", "ConstrainISODate", "ES.CreateTemporalYearMonth", "useYear", "ES.CreateTemporalMonthDay", "merged", "nextKey", "newKeys", "ES.AddISODate", "ES.DifferenceISODate", "ES.DayOfWeek", "ES.DayOfYear", "WeekOfYear", "doy", "DayOfYear", "dow", "DayOfWeek", "doj", "week", "LeapYear", "ES.ISODaysInMonth", "ES.LeapYear", "OneObjectCache", "cacheToClone", "map", "Map", "calls", "hits", "misses", "now", "performance", "Date", "i", "entry", "MAX_CACHE_ENTRIES", "result", "report", "setObject", "obj", "objectMap", "getCacheForObject", "cache", "toUtcIsoDateString", "isoYear", "isoMonth", "isoDay", "ES.ISOYearString", "ES.ISODateTimePartString", "simpleDateDiff", "HelperBase", "eraLength", "hasEra", "getFormatter", "formatter", "timeZone", "isoToCalendarDate", "isoDate", "JSON", "stringify", "func", "cached", "dateTimeFormat", "parts", "isoString", "formatToParts", "e", "type", "matches", "exec", "monthExtra", "split", "normalize", "replace", "toLowerCase", "reviseIntlEra", "checkIcuBugs", "adjustCalendarDate", "forEach", "keyReverse", "validateCalendarDate", "test", "constantEra", "calendarDateParam", "fromLegacyDate", "calendarType", "largestMonth", "regulateMonthDayNaive", "maximumMonthLength", "calendarToIsoDate", "originalDate", "keyOriginal", "isoEstimate", "estimateIsoDate", "calculateSameMonthResult", "diffDays", "testIsoEstimate", "addDaysIso", "minimumMonthLength", "testCalendarDate", "sign", "roundtripEstimate", "diff", "diffTotalDaysEstimate", "compareCalendarDates", "increment", "maybeConstrained", "oldRoundtripEstimate", "oldSign", "temporalToCalendarDate", "date1Param", "date2Param", "date1", "date2", "ES.ComparisonResult", "regulateDate", "addDaysCalendar", "addedIso", "addMonthsCalendar", "absMonths", "oldCalendarDate", "max", "daysInPreviousMonth", "monthsInOldYear", "addCalendar", "addedMonths", "initialDays", "untilCalendar", "calendarOne", "calendarTwo", "calendarDaysUntil", "totalDays", "diffYears", "diffMonths", "current", "next", "min", "addedIsoDate", "addedCalendarDate", "endOfMonthIso", "previousMonthDate", "previousMonth", "lastDayOfPreviousMonthIso", "startOfCalendarYear", "startOfCalendarMonth", "oneIso", "twoIso", "isoDaysUntil", "closestCalendar", "closestIso", "calendarYear", "roundTripCalendarDate", "HebrewHelper", "super", "Tishri", "regular", "Heshvan", "Kislev", "Tevet", "Shevat", "Adar", "Nisan", "Iyar", "Sivan", "Tamuz", "Av", "Elul", "minMaxMonthLength", "minOrMax", "getMonthCode", "monthInfo", "find", "m", "endsWith", "IslamicBaseHelper", "DAYS_PER_ISLAMIC_YEAR", "DAYS_PER_ISO_YEAR", "IslamicHelper", "IslamicUmalquraHelper", "IslamicTblaHelper", "IslamicCivilHelper", "IslamicRgsaHelper", "IslamicCcHelper", "PersianHelper", "IndianHelper", "nextYear", "vulnerableToBceBug", "toLocaleDateString", "isGregorianLeapYear", "getMonthInfo", "GregorianBaseHelper", "originalEras", "v8IsVulnerableToJulianBug", "calendarIsVulnerableToJulianBug", "eras", "anchorEra", "adjustEras", "erasParam", "reverseOf", "filter", "isAnchor", "anchorEpoch", "hasYearZero", "reversedEra", "isoEpoch", "e1", "e2", "lastEraReversed", "genericName", "indexOf", "completeEraYear", "checkField", "currentValue", "eraFromYear", "adjustedCalendarDate", "matchingEra", "ES.CompareISODate", "OrthodoxBaseHelper", "EthioaaHelper", "CopticHelper", "EthiopicHelper", "RocHelper", "BuddhistHelper", "GregoryHelper", "JapaneseHelper", "ChineseBaseHelper", "getMonthList", "getCalendarDate", "daysPastFeb1", "isoStringFeb1", "legacyDate", "setUTCDate", "newYearGuess", "calendarMonthString", "tv", "calendarDay", "calendarYearToVerify", "isoDaysDelta", "oldCalendarDay", "oldMonthString", "monthIndex", "done", "monthString", "withoutML", "monthEntries", "matchingMonthEntry", "v", "ChineseHelper", "DangiHelper", "nonIsoImpl", "helper", "fieldsCopy", "additionalFieldsCopy", "original", "newMonth", "newMonthCode", "newYear", "newEra", "newEraYear", "added", "isoAdded", "newTemporalObject", "cacheOne", "cacheTwo", "startOfYear", "startOfMonthCalendar", "startOfNextMonthCalendar", "startOfYearCalendar", "startOfNextYearCalendar", "Helper", "BUILTIN_CALENDAR_IDS", "tzComponent", "timeZoneID", "RegExp", "source", "calComponent", "calendarID", "yearpart", "monthpart", "daypart", "datesplit", "timesplit", "offset", "zonesplit", "zoneddatetime", "time", "yearmonth", "monthday", "fraction", "durationTime", "MathMin", "MathMax", "MathSign", "MathTrunc", "trunc", "NumberIsNaN", "Number", "NumberIsFinite", "isFinite", "NumberCtor", "StringCtor", "String", "NumberMaxSafeInteger", "MAX_SAFE_INTEGER", "ObjectCreate", "ObjectIs", "is", "ReflectApply", "Reflect", "apply", "ZERO", "JSBI", "BigInt", "ONE", "SIXTY", "THOUSAND", "MILLION", "BILLION", "NEGATIVE_ONE", "DAY_NANOS", "multiply", "NS_MIN", "NS_MAX", "BEFORE_FIRST_OFFSET_TRANSITION", "ABOUT_TEN_YEARS_NANOS", "ABOUT_ONE_YEAR_NANOS", "TWO_WEEKS_NANOS", "IsInteger", "IsObject", "ToNumber", "ToInteger", "num", "integer", "ToString", "ToIntegerThrowOnInfinity", "ToPositiveInteger", "valueParam", "property", "ToIntegerWithoutRounding", "divmod", "x", "y", "quotient", "divide", "remainder", "lessThan", "BUILTIN_CASTS", "ALLOWED_UNITS", "SINGULAR_PLURAL_UNITS", "IntlDateTimeFormatEnUsCache", "getIntlDateTimeFormatEnUsForTimeZone", "timeZoneIdentifier", "instance", "hour12", "hour", "minute", "second", "IsTemporalInstant", "IsTemporalTimeZone", "IsTemporalCalendar", "IsTemporalDuration", "IsTemporalDate", "IsTemporalTime", "IsTemporalDateTime", "IsTemporalYearMonth", "IsTemporalMonthDay", "IsTemporalZonedDateTime", "RejectObjectWithCalendarOrTimeZone", "ParseTemporalTimeZone", "stringIdent", "ianaName", "z", "ParseTemporalTimeZoneString", "canonicalIdent", "GetCanonicalTimeZoneIdentifier", "TestTimeZoneOffsetString", "ParseISODateTime", "FormatCalendarAnnotation", "showCalendar", "match", "PARSE.zoneddatetime", "yearString", "hasTime", "millisecond", "microsecond", "nanosecond", "offsetSign", "offsetHours", "offsetMinutes", "offsetSeconds", "offsetFraction", "ParseTemporalYearMonthString", "PARSE.yearmonth", "ParseTemporalMonthDayString", "PARSE.monthday", "referenceISOYear", "ParseTemporalDurationString", "PARSE.duration", "every", "element", "hours", "fHours", "minutes", "fMinutes", "seconds", "fSeconds", "milliseconds", "microseconds", "nanoseconds", "DurationHandleFractions", "fHoursParam", "minutesParam", "fMinutesParam", "secondsParam", "millisecondsParam", "microsecondsParam", "nanosecondsParam", "val", "mins", "secs", "mils", "fMilliseconds", "mics", "fMicroseconds", "ParseTemporalInstant", "ParseTemporalInstantString", "epochNs", "GetEpochFromISOParts", "offsetNs", "ParseTimeZoneOffsetString", "subtract", "RegulateISODate", "dayParam", "RegulateTime", "hourParam", "minuteParam", "secondParam", "millisecondParam", "microsecondParam", "nanosecondParam", "RejectTime", "ConstrainTime", "ConstrainToRange", "ToTemporalDurationRecord", "props", "ToPartialRecord", "ToLimitedTemporalDuration", "disallowedProperties", "record", "RejectDuration", "ToTemporalOverflow", "GetOption", "ToTemporalDisambiguation", "ToTemporalRoundingMode", "fallback", "NegateTemporalRoundingMode", "roundingMode", "ToTemporalOffset", "ToShowCalendarOption", "ToTemporalRoundingIncrement", "dividend", "inclusive", "maximum", "Infinity", "GetNumberOption", "minimum", "valueRaw", "ToTemporalDateTimeRoundingIncrement", "smallestUnit", "ToSecondsStringPrecision", "ToSmallestTemporalUnit", "precision", "unit", "digits", "fractionalSecondDigits", "stringDigits", "ToLargestTemporalUnit", "disallowedStrings", "autoValue", "singular", "sing", "s", "retval", "ToRelativeTemporalObject", "relativeTo", "offsetBehaviour", "matchMinutes", "TemporalDateTimeToDate", "GetTemporalCalendarWithISODefault", "ToTemporalDateTimeFields", "CalendarFields", "dateOptions", "InterpretTemporalDateTimeFields", "GetISO8601Calendar", "ToTemporalCalendar", "ToTemporalTimeZone", "CreateTemporalZonedDateTime", "InterpretISODateTimeOffset", "CreateTemporalDate", "ValidateTemporalUnitRange", "DefaultTemporalLargestUnit", "LargerOfTwoTemporalUnits", "unit1", "unit2", "bagParam", "bag", "any", "PrepareTemporalFields", "fieldRecord", "defaultValue", "ToTemporalDateFields", "fieldNames", "fieldName", "some", "ToTemporalMonthDayFields", "ToTemporalTimeRecord", "ToTemporalYearMonthFields", "ToTemporalDate", "itemParam", "BuiltinTimeZoneGetPlainDateTimeFor", "DateFromFields", "ParseTemporalDateString", "ToTemporalDateTime", "CreateTemporalDateTime", "ParseTemporalDateTimeString", "RejectDateTime", "ToTemporalDuration", "ToTemporalInstant", "ns", "ToTemporalMonthDay", "calendarAbsent", "maybeStringCalendar", "MonthDayFromFields", "CreateTemporalMonthDay", "ToTemporalTime", "ParseTemporalTimeString", "PARSE.time", "ToTemporalYearMonth", "YearMonthFromFields", "CreateTemporalYearMonth", "disambiguation", "offsetOpt", "matchMinute", "dt", "BuiltinTimeZoneGetInstantFor", "possibleInstants", "GetPossibleInstantsFor", "candidate", "candidateOffset", "GetOffsetNanosecondsFor", "roundedCandidateOffset", "toNumber", "RoundNumberToIncrement", "offsetStr", "FormatTimeZoneOffsetString", "timeZoneString", "DisambiguatePossibleInstants", "ToTemporalZonedDateTime", "ToTemporalZonedDateTimeFields", "ParseTemporalZonedDateTimeString", "CreateTemporalDateSlots", "RejectDateRange", "TemporalPlainDate", "CreateTemporalDateTimeSlots", "h", "ms", "S", "RejectDateTimeRange", "TemporalPlainDateTime", "CreateTemporalMonthDaySlots", "TemporalPlainMonthDay", "CreateTemporalYearMonthSlots", "RejectYearMonthRange", "RejectToRange", "TemporalPlainYearMonth", "CreateTemporalZonedDateTimeSlots", "epochNanoseconds", "ValidateEpochNanoseconds", "instant", "TemporalZonedDateTime", "fieldNamesParam", "CalendarMergeFields", "calMergeFields", "CalendarDateAdd", "dateAddParam", "CalendarDateUntil", "otherDate", "dateUntilParam", "CalendarYear", "dateLike", "CalendarMonth", "CalendarMonthCode", "CalendarDay", "CalendarEra", "CalendarEraYear", "CalendarDayOfWeek", "CalendarDayOfYear", "CalendarWeekOfYear", "CalendarDaysInWeek", "CalendarDaysInMonth", "CalendarDaysInYear", "CalendarMonthsInYear", "CalendarInLeapYear", "calendarLikeParam", "calendarLike", "identifier", "TemporalCalendar", "CalendarEquals", "ConsolidateCalendars", "sOne", "sTwo", "temporalTimeZoneLikeParam", "temporalTimeZoneLike", "TimeZoneEquals", "dateTime", "TemporalDateTimeToTime", "getOffsetNanosecondsFor", "BuiltinTimeZoneGetOffsetStringFor", "GetISOPartsFromEpoch", "BalanceISODateTime", "Instant", "numInstants", "utcns", "dayBefore", "dayAfter", "add", "offsetBefore", "PlainDateTime", "earlier", "AddDateTime", "later", "possible", "getPossibleInstantsFor", "ISOYearString", "ISODateTimePartString", "part", "FormatSecondsStringPart", "fractionNumber", "TemporalInstantToString", "outputTimeZone", "FormatISOTimeZoneOffsetString", "TemporalDurationToString", "formatNumber", "DurationSign", "RoundDuration", "dateParts", "timeParts", "secondParts", "nsBigInt", "R", "msBigInt", "secondsBigInt", "total", "TotalDurationNanoseconds", "decimalPart", "unshift", "equal", "join", "TemporalDateToString", "TemporalDateTimeToString", "RoundISODateTime", "TemporalMonthDayToString", "monthDay", "resultString", "calendarString", "TemporalYearMonthToString", "yearMonth", "TemporalZonedDateTimeToString", "zdt", "showTimeZone", "showOffset", "RoundInstant", "tz", "string", "OFFSET", "resolvedOptions", "GetIANATimeZoneOffsetNanoseconds", "GetIANATimeZoneDateTimeParts", "utc", "offsetNanosecondsParam", "offsetNanoseconds", "hourString", "minuteString", "secondString", "post", "setUTCHours", "setUTCFullYear", "getTime", "greaterThan", "epochMilliseconds", "nanos", "getUTCFullYear", "getUTCMonth", "getUTCDate", "getUTCHours", "getUTCMinutes", "getUTCSeconds", "getUTCMilliseconds", "GetFormatterParts", "parseFromEnUsFormat", "datetime", "toUpperCase", "format", "maxJSBI", "afterLatestPossibleTzdbRuleChange", "SystemUTCEpochNanoSeconds", "GetIANATimeZonePreviousTransition", "afterLatestRule", "isFarFuture", "lowercap", "rightNanos", "rightOffsetNs", "leftNanos", "leftOffsetNs", "bisect", "ISODaysInMonth", "standard", "leapyear", "Y", "c", "mon", "w", "d", "l", "BalanceISOYearMonth", "BalanceISODate", "testYear", "deltaDays", "BalanceTime", "NonNegativeModulo", "daysParam", "hoursParam", "offsetShift", "NanosecondsToDays", "TemporalInstant", "dayLengthNs", "startNs", "start", "endNs", "end", "dtStart", "dtEnd", "DifferenceISODateTime", "intermediateNs", "AddZonedDateTime", "isOverflow", "relativeInstant", "oneDayFartherNs", "relativeNs", "BalanceDuration", "nanosecondsBigInt", "microsecondsBigInt", "millisecondsBigInt", "minutesBigInt", "hoursBigInt", "UnbalanceDurationRelative", "yearsParam", "monthsParam", "weeksParam", "relativeToParam", "TemporalDuration", "oneYear", "oneMonth", "oneWeek", "relativeToDateOnly", "newRelativeTo", "untilOptions", "oneYearMonths", "oneYearDays", "MoveRelativeDate", "oneMonthDays", "oneWeekDays", "CalculateOffsetShift", "after", "CreateNegatedTemporalDuration", "propSign", "DifferenceISODate", "y1", "m1", "d1", "y2", "m2", "d2", "CompareISODate", "mid", "AddISODate", "midSign", "larger", "smaller", "DifferenceTime", "h1", "min1", "s1", "ms1", "r", "ns1", "h2", "min2", "s2", "ms2", "ns2", "DifferenceInstant", "wholeDays", "roundedRemainder", "nsPerTimeUnit", "roundedDiff", "y1Param", "mon1Param", "d1Param", "mon2", "f", "mon1", "timeSign", "DifferenceZonedDateTime", "nsDiff", "timeRemainderNs", "intermediate", "AddTime", "AddDuration", "w1", "w2", "G", "dateDuration1", "dateDuration2", "dateLargestUnit", "differenceOptions", "AddInstant", "sum", "addedDate", "I", "dtIntermediate", "quantity", "mode", "RoundTime", "nsPerUnit", "rounded", "DaysUntil", "MoveRelativeZonedDateTime", "AdjustRoundedDurationDays", "direction", "dayStart", "dayEnd", "greaterThanOrEqual", "zdtRelative", "dayLength", "yearsDuration", "yearsLater", "yearsMonthsWeeksLater", "daysLater", "yearsPassed", "oldRelativeTo", "divisor", "yearsMonths", "yearsMonthsLater", "allNanoseconds", "ComparisonResult", "ToBigIntExternal", "arg", "jsbiBI", "ToBigInt", "prim", "toPrimFn", "toPrimitive", "SyntaxError", "message", "GetOptionsObject", "CreateOnePropObject", "propName", "propValue", "o", "allowedValues", "PARSE.offset", "getState", "leftParam", "rightParam", "lstateParam", "rstateParam", "left", "right", "lstate", "rstate", "middle", "mstate", "DATE", "YM", "MD", "TIME", "DATETIME", "ZONED", "INST", "ORIGINAL", "TZ_RESOLVED", "TZ_GIVEN", "CAL_ID", "LOCALE", "OPTIONS", "descriptor", "ObjectAssign", "assign", "ObjectHasOwnProperty", "hasOwnProperty", "getPropLazy", "getResolvedTimeZoneLazy", "ES.ToTemporalTimeZone", "DateTimeFormatImpl", "locale", "hasOptions", "ro", "clonedResolved", "dateAmend", "yearMonthAmend", "monthDayAmend", "timeAmend", "datetimeAmend", "zonedDateTimeAmend", "instantAmend", "supportedLocalesOf", "locales", "properties", "rest", "extractOverrides", "adjustFormatterTimeZone", "formatRange", "a", "b", "isTemporalObject", "sameTemporalType", "aa", "aformatter", "atz", "bb", "bformatter", "btz", "formatRangeToParts", "amend", "amended", "opt", "weekday", "timeZoneName", "dateStyle", "hasTimeOptions", "dayPeriod", "timeStyle", "hasDateOptions", "ES.IsTemporalDate", "ES.IsTemporalTime", "ES.IsTemporalDateTime", "ES.IsTemporalZonedDateTime", "ES.IsTemporalInstant", "temporalObj", "main", "DateTime", "ES.BuiltinTimeZoneGetInstantFor", "objTimeZone", "DISALLOWED_UNITS", "MAX_DIFFERENCE_INCREMENTS", "ES.ToBigInt", "ES.ValidateEpochNanoseconds", "epochSeconds", "epochMicroseconds", "ES.ToBigIntExternal", "temporalDurationLike", "ES.ToLimitedTemporalDuration", "ES.AddInstant", "until", "otherParam", "other", "ES.ToTemporalInstant", "ES.ToSmallestTemporalUnit", "defaultLargestUnit", "ES.LargerOfTwoTemporalUnits", "ES.ValidateTemporalUnitRange", "ES.ToTemporalRoundingMode", "roundingIncrement", "ES.ToTemporalRoundingIncrement", "onens", "twons", "ES.DifferenceInstant", "since", "round", "ES.CreateOnePropObject", "roundedNs", "ES.RoundInstant", "equals", "ES.ToSecondsStringPrecision", "ES.TemporalInstantToString", "toLocaleString", "valueOf", "toZonedDateTime", "ES.CreateTemporalZonedDateTime", "toZonedDateTimeISO", "timeZoneProperty", "ES.GetISO8601Calendar", "fromEpochSeconds", "epochSecondsParam", "ES.ToNumber", "fromEpochMilliseconds", "epochMillisecondsParam", "fromEpochMicroseconds", "epochMicrosecondsParam", "fromEpochNanoseconds", "epochNanosecondsParam", "compare", "oneNs", "twoNs", "PlainDate", "isoYearParam", "isoMonthParam", "isoDayParam", "calendarParam", "ES.ToIntegerThrowOnInfinity", "ES.CreateTemporalDateSlots", "ES.CalendarEra", "ES.CalendarEraYear", "ES.CalendarYear", "ES.CalendarMonth", "ES.CalendarMonthCode", "ES.CalendarDay", "ES.CalendarDayOfWeek", "ES.CalendarDayOfYear", "ES.CalendarWeekOfYear", "ES.CalendarDaysInWeek", "ES.CalendarDaysInMonth", "ES.CalendarDaysInYear", "ES.CalendarMonthsInYear", "ES.CalendarInLeapYear", "with", "temporalDateLike", "ES.RejectObjectWithCalendarOrTimeZone", "ES.CalendarFields", "ES.ToPartialRecord", "ES.ToTemporalDateFields", "ES.CalendarMergeFields", "ES.DateFromFields", "withCalendar", "ES.CalendarDateAdd", "ES.CreateNegatedTemporalDuration", "otherCalendar", "calendarId", "otherCalendarId", "ES.CalendarDateUntil", "ES.RoundDuration", "Duration", "ES.NegateTemporalRoundingMode", "slot", "ES.CalendarEquals", "ES.TemporalDateToString", "ES.ToShowCalendarOption", "toPlainDateTime", "temporalTimeParam", "ES.CreateTemporalDateTime", "temporalTime", "ES.ToTemporalTime", "timeZoneLike", "plainTime", "toPlainYearMonth", "ES.YearMonthFromFields", "ES.ToTemporalYearMonthFields", "toPlainMonthDay", "ES.MonthDayFromFields", "ES.ToTemporalMonthDayFields", "getISOFields", "ES.CreateTemporalDateTimeSlots", "temporalDateTimeLike", "ES.ToTemporalDateTimeFields", "ES.InterpretTemporalDateTimeFields", "withPlainTime", "withPlainDate", "temporalDateParam", "temporalDate", "ES.ConsolidateCalendars", "ES.AddDateTime", "ES.ToTemporalDateTime", "ES.ToTemporalDateTimeRoundingIncrement", "ES.DifferenceISODateTime", "ES.TemporalDateTimeToDate", "ES.RoundISODateTime", "ES.TemporalDateTimeToString", "ES.ToTemporalDisambiguation", "toPlainDate", "toPlainTime", "ES.TemporalDateTimeToTime", "isoHour", "isoMicrosecond", "isoMillisecond", "isoMinute", "isoNanosecond", "isoSecond", "val1", "val2", "ES.ToIntegerWithoutRounding", "ES.DurationSign", "ES.IsTemporalDuration", "blank", "durationLike", "negated", "ES.ToRelativeTemporalObject", "ES.AddDuration", "ES.DefaultTemporalLargestUnit", "smallestUnitPresent", "largestUnitPresent", "ES.UnbalanceDurationRelative", "ES.AdjustRoundedDurationDays", "BalanceDurationRelative", "untilResult", "ES.MoveRelativeZonedDateTime", "ToTemporalDurationTotalUnit", "values", "ES.TemporalDurationToString", "DurationFormat", "console", "warn", "p", "j", "shift1", "ES.CalculateOffsetShift", "shift2", "totalNs1", "ES.TotalDurationNanoseconds", "totalNs2", "PlainMonthDay", "referenceISOYearParam", "ES.CreateTemporalMonthDaySlots", "temporalMonthDayLike", "ES.ToTemporalMonthDay", "ES.TemporalMonthDayToString", "receiverFieldNames", "inputFieldNames", "inputEntries", "mergedFields", "mergedFieldNames", "mergedEntries", "ES.SystemUTCEpochNanoSeconds", "plainDateTime", "tZ", "ES.BuiltinTimeZoneGetPlainDateTimeFor", "plainDateTimeISO", "zonedDateTime", "SystemTimeZone", "fmt", "ES.SystemTimeZone", "Now", "plainDate", "plainDateISO", "plainTimeISO", "zonedDateTimeISO", "MAX_INCREMENTS", "TemporalTimeToString", "ES.RoundTime", "ES.FormatSecondsStringPart", "PlainTime", "isoHourParam", "isoMinuteParam", "isoSecondParam", "isoMillisecondParam", "isoMicrosecondParam", "isoNanosecondParam", "ES.RejectTime", "temporalTimeLike", "ES.ToTemporalTimeRecord", "ES.RegulateTime", "ES.AddTime", "ES.DifferenceTime", "TimeZone", "timeZoneIdentifierParam", "ES.GetCanonicalTimeZoneIdentifier", "ES.IsTemporalTimeZone", "instantParam", "ES.TestTimeZoneOffsetString", "ES.ParseTimeZoneOffsetString", "ES.GetIANATimeZoneOffsetNanoseconds", "getOffsetStringFor", "ES.BuiltinTimeZoneGetOffsetStringFor", "getPlainDateTimeFor", "getInstantFor", "dateTimeParam", "ES.GetEpochFromISOParts", "GetIANATimeZoneEpochValue", "nsEarlier", "nsLater", "earliest", "latest", "getNextTransition", "startingPointParam", "startingPoint", "GetIANATimeZoneNextTransition", "oneYearLater", "uppercap", "getPreviousTransition", "ES.GetIANATimeZonePreviousTransition", "PlainYearMonth", "referenceISODayParam", "ES.CreateTemporalYearMonthSlots", "temporalYearMonthLike", "startDate", "ES.ToPositiveInteger", "optionsCopy", "ES.ToTemporalYearMonth", "otherCalendarID", "otherFields", "thisFields", "thisDate", "ES.TemporalYearMonthToString", "ZonedDateTime", "timeZoneParam", "ES.CreateTemporalZonedDateTimeSlots", "hoursInDay", "today", "tomorrowFields", "tomorrow", "todayNs", "tomorrowNs", "ES.GetOffsetNanosecondsFor", "temporalZonedDateTimeLike", "ES.ToTemporalOffset", "ES.InterpretISODateTimeOffset", "thisDt", "withTimeZone", "ES.AddZonedDateTime", "ES.ToTemporalZonedDateTime", "ES.TimeZoneEquals", "ES.DifferenceZonedDateTime", "instantStart", "ES.TemporalZonedDateTimeToString", "ToShowTimeZoneNameOption", "ToShowOffsetOption", "startOfDay", "toInstant", "types", "Temporal.Instant", "Temporal.Calendar", "Temporal.PlainDate", "Temporal.PlainDateTime", "Temporal.Duration", "Temporal.PlainMonthDay", "Temporal.PlainTime", "Temporal.TimeZone", "Temporal.PlainYearMonth", "Temporal.ZonedDateTime", "type", "descriptor", "Object", "getOwnPropertyDescriptor", "configurable", "enumerable", "writable", "defineProperty", "timeZone", "i", "timezones", "place"]
}
